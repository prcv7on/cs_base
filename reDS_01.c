

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


//00 数据结构与算法，应该这样学！
//真题实际上是刨除了特定场景和业务问题后，对实际解决问题的方法的提炼。 --> 最终回归到能力培养上来
//0.1 课程特色
//(1) 程序优化的通用方法论
//(2) 高频使用的数据结构就那么几个，其他往往是这些基础知识点的不同组合与变形
//(3) 内容精简，且重视方法论的建设，可快速建立程序优化的思想，并牢牢掌握知识体系中最核心、最根本的内容。
//0.1 jiyu
//成为核心骨干的一个先决条件，准确的技术选型和扎实的代码基础，最基本的条件是掌握算法思维和数据结构原理，
//在学习的过程中多动手练习和实践，真正达成内化吸收的闭环。

//01 复杂度：如何衡量程序运行的效率？
//1.1 复杂度是什么?   -->   衡量代码运行效率的重要度量
//编写代码的核心就是要完成计算
//1.1.1 衡量复杂度的两个维度:
//(1)这段代码消耗的资源是什么  --> 消耗计算时间和计算空间
//(2)这段代码对于资源的消耗是多少  --> 时间或者空间消耗量与输入数据量之间的关系
//1.1.2 计算复杂度方法 O(f(n))
//遵循以下几个原则:
//(1)复杂度与具体的常系数无关
//(2)多项式级的复杂度相加，选择高者作为结果
//(3)O(1)特殊复杂度,某个任务通过有限可数的资源即可完成. 与输入数据量 n 无关

//1.2 时间复杂度与代码结构的关系
//(1)时间复杂度与 代码结构 紧密关系
//(2)空间复杂度与 数据结构的设计有关
//1.2.1 经验性的结论
//(1)顺序结构的代码，时间复杂度O(1)
//(2)采用分而治之的二分策略, O(log(n))
//(3)简单for循环，O(n)
//(4)两个顺序执行的 for 循环, O(2n)=O(n)
//(5)两个嵌套的 for 循环， O(n²)

//1.3 降低时间复杂度的必要性
//大数据环境下，时间复杂度的优化将带来巨大的系统收益

//1.4 总结
//具体计算复杂度时需要注意:
//(1)与具体的常系数无关
//(2)复杂度相加的时候，选择高者作为结果
//(3)O(1)表示一个特殊复杂度，即任务与个数n无关

//1.5 练习题


//02 数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度
//代码效率优化: 将可行解提高到更优解，
//最终目标：采用尽可能低的时间和空间复杂度，去完成一段代码的开发
//代码效率的提高也有其核心思路

//2.1 时间昂贵、空间廉价
//相比于空间复杂度，时间复杂度的降低就显得更加重要了。

//2.2 数据结构连接时空
//降低复杂度的直观思路：梳理程序，看流程中是否有无效的计算或无效的存储
//2.2.1 降低时间复杂度的方法: 递归、二分法、排序算法、动态规划
//2.2.2 降低空间复杂度的方法: 围绕数据结构
//核心思路就是，能用低复杂度的数据结构能解决问题，就千万不要用高复杂度的数据结构。
//2.2.3 把时间复杂度转移到空间复杂度
//连接时间和空间的桥梁就是数据结构:
//数据结构合理，再次降低时间复杂度，通常会增加数据的存储量，增加空间复杂度
//2.2.4 简单梳理如下:
//(1)第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。
//(2)第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
//(3)第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

//2.3 降低复杂度的案例
//查找出一个数组中，出现次数最多的那个元素的数值。
//定义一个k-v结构的字典，存放元素-出现次数的k-v关系。
//首先通过一次循环，将数组转变为元素-出现次数的一个字典。接下来，再去遍历一遍这个字典，找到出现次数最多的那个元素，就能找到最后的结果

/*
typedef struct KeyValue {
    int val;
    int cnt;
}KV;

int maxCount(int* a, int n) {
    KV kv;
    kv.val=a[0];
    kv.cnt=1;
    for (int i=1;i<n;++i) {
        if (kv.cnt == 0) kv.val=a[i];
        if (a[i] == kv.val) ++kv.cnt;
        else --kv.cnt;
    }
    return kv.val;
}

int main(void) {
    int arr[10]={1, 2, 3, 4, 5, 5, 6,5,7,9};
    int maxcnt=maxCount(arr,10);
    printf("maxcnt=%d\n", maxcnt);//5
    return 0;
}
*/

//2.4 总结
//第一步的暴力解法没有太多的套路，只要围绕你面临的问题出发，大胆发挥想象去尝试解决即可。
//第二步的无效操作处理中，你需要学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维。
//第三步的时空转换，你需要对数据的操作进行细分，全面掌握常见数据结构的基础知识。
//再围绕问题，有针对性的设计数据结构、采用合理的算法思维，去不断完成时空转移，降低时间复杂度。

//2.5 练习题



//03 增删查：掌握数据处理的基本操作,以不变应万变
//要想灵活使用数据结构，先弄清楚数据在代码中被处理、加工的最小单位动作，即数据结构的基本操作
//3.1 代码对数据的处理
//字典的查找通过键值对的匹配完成，时间复杂度O(1)

//3.2 数据处理的基本操作
//3.2.1 设计合理的数据结构,要从问题本身出发,b思考顺序:
//(1)这段代码到底对数据先后进行了哪些操作
//(2)根据数据操作，找到合理的数据结构
//更复杂的问题，无非是这些基本操作的叠加和组合。
//3.2.2 数据处理的操作
//(1)找到要处理的数据。按照某些条件进行查找。
//(2)把结果存到一个新的内存空间中。在现有数据上进行新增。
//(3)把结果存到一个已使用的内存空间中。需要先删除内存空间中的已有数据，再新增新的数据。
//围绕这 3 个数据处理的操作进行分析，就能得出解决问题的最优方案
//3.2.3 分析方法
//(1)这段代码对数据进行了哪些操作
//(2)哪个操作最影响效率，对时间复杂度的损耗最大？
//(3)哪种数据结构最能帮助提高数据操作的效率？

//3.3 数据操作与数据结构的案例
//3.3.1 查找数据
//(1)根据元素的位置或索引来查找
//(2)根据元素的数值特征来查找
//3.3.2 新增数据
//(1)在这个复杂数据结构的最后，新增一条数据
//(2)在这个复杂数据结构的中间某个位置，新增一条数据。
//区别在于: 新增数据之后, 原有数据结构中数据的位置顺序改变
//3.3.3 删除数据
//(1)在这个复杂数据结构的最后，删除一条数据
//(2)在这个复杂数据结构的中间某个位置，删除一条数据。

//3.4 总结
//只有充分了解问题、明确数据操作的方法，才能设计出更加高效的数据结构类型。
//数据处理的基本操作只有3个，增、删、查。
//几乎所有的数据处理，都是这些基本操作的组合和叠加。

//3.5 练习题
//不知道该用什么数据结构时，要回归问题本源。
//从数据需要被处理的动作出发。只有明确了动作，才能找到最合适的解决方法


//04 如何完成线性表结构下的增删查？
//4.1 什么是数据结构？
//数据的组织方式。
//能有效解决问题的高效率数据结构比较有限, 把这些能真正解决问题的数据结构学会.

//4.2 什么是线性表
//循环链表
//双向链表
//双向循环链表

//4.3 线性表对于数据的增删查处理
//单向链表为例
//4.3.1 新增(s指向新节点，p指向新增位置)
//s.next=p.next
//p.next=s
//4.3.2 删除
//p.next=p.next.next
//4.3.3 查找
//按位置/数值条件的查找, 遍历全部数据, 时间复杂度O(n)
//新增、删除: 时间复杂度O(1)
//4.3.4 线性表真正的价值: 对数据的存储方式是按照顺序的存储。
//若元素个数不定，需要经常新增和删除，则链表比较合适
//元素个数确定，删除新增操作不多，则数组合适

//4.4 线性表案例

// typedef struct SingleNode {
//     int val;
//     struct SingleNode* next;
// }SN;
// typedef struct SingleList {
//     SN* head;
//     int size;
// }sList;

//4.4.1 链表的翻转。
//给定一个链表，输出翻转后的链表。例如，输入1 ->2 -> 3 -> 4 ->5，输出 5 -> 4 -> 3 -> 2 -> 1。

// SN* reverse_sList(sList* ps) {
//     SN* cur=ps->head;
//     SN* prv=NULL;
//     SN* next=NULL;
//     while (cur) {
//         next=cur->next;
//         cur->next=prv;
//         prv=cur;
//         cur=next;
//     }
//     ps->head=prv;
//     return ps->head;
// }

//4.4.2 给定奇数个元素的链表，查找出这个链表中间位置的结点的数值。
//巧妙的办法，就是利用快慢指针.快指针每次向后跳转两次，而慢指针每次向后跳转一次。

// int mid_sList(sList* ps) {
//     SN* fast=ps->head;
//     SN* slow=fast;
//     while (fast && fast->next && fast->next->next) {
//         fast=fast->next->next;
//         slow=slow->next;
//     }
//     return slow->val;
// }

//4.4.3 判断链表是否有环。
//快指针每次走两格，而慢指针每次走一格
//若有环，快慢指针一定会在环内相遇，即fast == slow 一定会发生
//反之，则最终会完成循环，二者从未相遇

// bool isCircledList(sList* ps) {
//     SN* fast=ps->head;
//     SN* slow=fast;
//     while (fast && fast->next && fast->next->next) {
//         fast=fast->next->next;
//         slow=slow->next;
//         if (fast == slow) {
//             printf("Circled.\n");
//             break;
//         }
//     }
//     return fast==slow ? true : false;
// }

/*
void printsList(sList* ps) {
    printf("sList: ");
    SN* p=ps->head;
    while (p) {
        printf("%d -> ", p->val);
        p=p->next;
    }
    printf("NULL\n");
}

void printArr(int* a, int n) {
    for (int i=n-1;i>=0;--i) {
        printf("%d -> ",a[i]);
    }
    printf("NULL\n");
}

int* reverse_List(sList* ps) {
    SN* p=ps->head;
    int* arr=(int*)malloc( sizeof(int) * (ps->size) );
    int i=-1;
    while (p) {
        arr[++i]=p->val;
        printf("p->val=%d\n",p->val);
        p=p->next;
    }
    printf("i=%d\n",i);
    return arr;
}

int main(void) {
    SN n1,n2,n3,n4,n5;
    n1.val=1; n1.next=&n2;
    n2.val=2; n2.next=&n3;
    n3.val=3; n3.next=&n4;
    n4.val=4; n4.next=&n5;
    n5.val=5; n5.next=NULL;
    sList sl;
    sl.head=&n1;
    sl.size=5;
    // SN* p=reverse_sList(&sl);
    //printsList(&sl);
    //printsList(p);
    int* p=reverse_List(&sl);
    printArr(p,5);
    //printf("p->val=%d\n",p->val);
    

    // int midval=mid_sList(&sl);
    // printf("mmidval=%d\n",midval);//3

    // bool bc=isCircledList(&sl);
    // printf("bc=%d\n",bc);//0

    return 0;
}
*/

//4.5 总结
//线性表的价值在于，它对数据的存储方式是按照顺序的存储。
//链表的翻转、快慢指针的方法，是你必须掌握的内容。

//4.6 练习题
//给定含有n个元素的链表，要求每k个节点一组进行翻转，打印翻转后的链表。其中，k是一个正整数，且可被n整除
//例如，链表为 1 -> 2 -> 3 -> 4 -> 5 -> 6，k = 3，则打印 321654。
//提示，这个问题需要使用到链表翻转的算法。


//05 栈：后进先出的线性表，如何实现增删查？
//严格遵守数据处理顺序, 需要对线性表予以限制

//5.1 栈是什么
//一种特殊的线性表, 必须后进先出
//从功能上讲，数组或链表可替代栈。问题是，操作过于灵活，即它们过多暴露了可操作的接口。带来风险。
//若问题只涉及在一端新增和删除数据， 效率更高
//(1)栈顶指针top: 输入数据
//(2)栈底指针

//5.2 栈的基本操作
//压栈push
//出栈pop
//5.2.1 顺序栈(数组)
//栈底=a[0]
//栈顶=a[n-1]
//空栈 <--> top==-1
//top < maxsize
//入栈: ++top
//出栈: --top

//5.2.2 链栈(链表)
//链栈不需要头指针
//栈顶top: 单链表的头部
//压栈: 操作与链表尾插入新数据基本相同， top==newNode
//出栈: top=top->next

//不管是顺序栈还是链栈,数据的增、删、查与线性表的操作原理极为相似，时间复杂度完全一样
//区别仅在于新增和删除的对象，只能是栈顶

//5.3 栈的案例
//给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
//有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。
//例如，{ [ ( ) ( ) ] } 合法，而 { ( [ ) ] } 非法
//具体为: 
//从左到右顺序遍历字符串。出现左括号，压栈。出现右括号，出栈。并且判断当前右括号，和被出栈的左括号是否互相匹配。如果不是，则字符串非法。
//当遍历完成之后，如果栈为空。则合法。

/*
bool isLegal(const char* s) {
    if (s==NULL || s[0]=='\0') return true;
    int n=strlen(s);
    printf("n=%d\n",n);
    if (n & 1) return false;
    char a[n];
    int top=-1;
    char ch;
    for (int i=0;i<n;++i) {
        if (s[i]=='{' || s[i]=='(' || s[i]=='[') 
            a[++top]=s[i];
        else {
            if (top==-1) return false;
            ch=a[top--];
            if (s[i]==')' && ch!='(') return false;
            else if (s[i]=='}' && ch!='{') return false;
            else if (s[i]==']' && ch!='[') return false;
        }
    }
    return top==-1;
}

int main() {
    char* s="()[]{}"; //{[]}  //
    //char* s="";
    bool b1=isLegal(s);
    printf("b1=%d\n",b1);

    return 0;
}
*/

//5.4 总结
//栈继承了线性表的优点与不足，是个限制版的线性表。
//问题需要高频新增、删除，且数据执行顺序具备后进先出，栈就是个不错的选择。

//5.5 练习题
//给定包含 n 个元素的链表，现在要求每 k 个节点一组进行翻转，打印翻转后的链表结果。其中，k 是一个正整数，且 n 可被 k 整除。
//例如，链表为 1 -> 2 -> 3 -> 4 -> 5 -> 6，k = 3，则打印 321654。仍然是这道题，我们试试用栈来解决它吧。
//代码见4.4.3 reverse_List()


//06 队列：先进先出的线性表，如何实现增删查？
//6.1 队列是什么
//6.1.1 一种特殊的线性表,先进先出:
//(1)先进: 只能在末端新增数据
//(2)先出: 只能在始端删除数据
//6.1.2 两种存储方式
//(1)顺序队列(数组): 数据在内存中顺序存储
//(2)链式队列(链表): 只能尾进头出的单链表
//6.1.3
//队头front:
//队尾tail:
//队列为空 <--> front==tail==头节点

//6.2 队列对于数据的增删查处理
//(1)插入元素: a[++tail]=val
//(2)删除元素: ++front, 无需移动剩余数据，可能会有数组越界问题，产生 “假溢出” 现象
//(3)简单粗暴的解决方法:
//不惜消耗 O(n) 的时间复杂度去移动数据
//开辟足够大的内存空间确保数组不会越界

//6.2.1 循环队列的数据操作
//队列的一个特殊变种来解决数组越界问题
//(1)新增: 先判断队列是否为满
//(2)删除: 先判断队列是否为空
//队列为空: flag==true && front==tail
//队列是满: flag!=true && front==tail

//6.2.2 链式队列的数据操作
//就是一个单链表
//通常增加一个头结点，front 指针指向头结点。头结点不存储数据，只用来辅助标识
//(1)新增: tail.next=newNode; tail=newNode; newNode->next=NULL
//(2)删除: 实际删除的是头结点的后继
//队列为何特被强调要有头结点?
//为了防止删除最后一个有效结点后, front和tail变成野指针， 导致队列没有意义。
//空队列 <--> front==tail==头节点

//6.3 队列的案例
//约瑟夫环问题

//6.4 总结
//(1)队列的增和删的操作只能在这个线性表的头和尾进行
//(2)循环队列必须有一个固定的长度，因此存在空间的浪费
//队列长度最大值确定时，使用循环队列。无法确定队列长度时，使用链式队列


//07 数组：如何实现基于索引的查找？
//数组可看成是线性表的一种推广
//7.1 数组是什么
//固定的基础变量类型。
//存放若干个相同类型元素的容器.
//数组在内存中连续存放, 通过索引值直接取出。 数组的索引就是对应数组空间

//7.2 数组的基本操作
//数组按顺序存储数据，存储数据的内存也连续 --> 增删困难、查找容易
//7.2.1 新增
//(1)末尾: 时间复杂度O(1)
//(2)中间: 时间复杂度O(n)
//7.2.2 删除
//(1)末尾: 时间复杂度O(1)
//(2)中间: 时间复杂度O(n)
//7.2.3 查找
//(1)索引值, 时间复杂度O(1)
//(2)查找一个满足指定条件的数值: 时间复杂度O(n)
//7.2.4
//封装好了的函数，其时间复杂度也不会发生改变。
//底层原理需要理解并掌握

//7.3 数组增删查操作的特点
//(1)链表长度可变，数组长度固定
//(2)链表用指针来充分利用内存空间
//数组的顺序存储, 库充分利用内存的空间

//7.4 数组的案例
//去除最高最低分后的平均分

/*
double avgScore(int* a, int n) {
    int max_idx,min_idx;
    int maxval=a[0],minval=a[0];
    int s;
    for (int i=0;i<n;++i) {
        if (a[i] > maxval) {
            maxval=a[i];
            max_idx=i;
        }
        if (a[i] < minval) {
            minval=a[i];
            min_idx=i;
        }
    }
    for (int i=0;i<n;++i) {
        if (i != max_idx && i != min_idx) 
            s += a[i];
    }
    return s/(n-2);
}
*/

//7.5 总结
//合理区分数组和链表的使用
//数组更适合: 数据数量确定, 新增、删除操作不多的情况，

//7.6 练习题
//给定一个排序数组，在原地删除重复元素，使得各元素只出现一次，返回移除后的数组和新长度，无需考虑数组中超出新长度后面的元素。
//要求，空间复杂度 O(1)，即不用额外的数组空间。
//给定 a = [0,0,1,1,1,2,2,3,3,4]，应该返回新长度 5，并且原数组 a 的前五个元素被修改为 0, 1, 2, 3, 4

/*
int removeDuplicates(int* a, int sz){
    if (sz<=1) return sz;
    int k=1;
    for (int i=1;i<sz;++i) {
        if (a[i] != a[i-1]){
            a[k++]=a[i];
        }
    }
    return k;
}

void printArr(int* a, int n) {
    printf("arr = ");
    for (int i=0;i<n;++i) {
        printf("%d ",a[i]);
    }
    printf("\n");
}

int main(void) {
    // int arr[9]={2,1,4,5,3,9,7,8,10};
    // double avg=avgScore(arr,9);
    // printf("avg=%.2f\n",avg);

    int arr[10]={0,0,1,1,1,2,2,3,3,4};
    int n=removeDuplicates(arr,10);
    printArr(arr,n);
    return 0;
}
*/



//08 字符串：如何正确回答面试中高频考察的字符串匹配算法？
//8.1 字符串是什么
//字符串的逻辑结构和线性表很相似, 针对的是字符集, 元素都是字符
//8.1.1 特殊的字符串
//(1)空串: ""
//(2)空格串: " "
//(3)子串: 串中任意连续字符组成的字符串
//(4)主串: 原串
//(5)相等: 对应位置，字符一致
//8.1.2 存储方式:
//(1)顺序存储: 地址连续的存储单元, 定长数组
//(2)链式存储: 各节点存储若干字符
//不如顺序存储灵活，性能也不如顺序存储好

//8.2 字符串的基本操作
//线性表更关注单个元素的操作，而字符串更多关注查找子串的位置、替换等操作
//8.2.1 新增
//(1)中间: 之后字符的挪移, 时间复杂度O(n)
//(2)末尾: 时间复杂度O(1) --> 字符串的连接
//8.2.2 删除
//(1)中间: 之后字符的挪移, 时间复杂度O(n)
//(2)末尾: 时间复杂度O(1) --> 在s1末尾删除若干个字符
//8.2.3 查找: 子串查找或字符串匹配
//8.2.4 子串查找（字符串匹配）
//在串A 中查找串B，则A是主串，B是模式串。把主串长度记为n，模式串长度记为m
//从主串中找到跟模式串的第 1 个字符相等的位置，然后再去匹配后续字符是否与模式串相等。
//时间复杂度O(nm)

//8.3 字符串匹配算法的案例
//查找出两个字符串的最大公共字串
//第一步需要两层循环去查找共同出现的字符， O(nm)。
//一旦找到共同出现的字符之后，还需再继续查找共同出现的字符串，则又嵌套一层循环。最终时间复杂度O(nmm)=O(nm²)

/*
typedef struct Stu {
    int beg;
    int len;
}St;

St maxStr(const char* s1, const char* s2) {
    size_t n1=strlen(s1);
    size_t n2=strlen(s2);
    St st;
    st.beg=st.len=0;

    for (int i=0; i<n1; ++i) {
        for (int j=0; j<n2; ++j) {
            if (s1[i]==s2[j]) {
                
                for (int m=i,n=j; m<n1 && n<n2; ++m,++n) {
                    if (s1[m] != s2[n]) break;
                    if (st.len < m-i+1) {
                        st.len=m-i+1;
                        st.beg=i;
                        printf("beg=%d\n",st.beg);
                    }
                }
            }
        }
    }
    return st;
}
*/

//8.4 总结
// 在线性表的基本操作中，大多以“单个元素”作为操作对象；
// 在字符串的基本操作中，通常以“串的整体”作为操作对象；
// 字符串的增删操作和数组很像，复杂度也与之一样。但字符串的查找操作就复杂多了，它是参加面试、笔试常常被考察的内容。

//8.5 练习题
//给定一个字符串，逐个翻转字符串中的每个单词。
//例如，输入: "the sky is blue"，输出: "blue is sky the"。
//说明：
// 无空格字符构成一个单词。
// 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
// 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
//用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。

/*
char* reverseWords(char* s) {
    while (*s == ' ') ++s;//消除前面多余空格
    size_t n=strlen(s)-1;
    if (n < 0) return s;
    while (s[n] == ' ') s[n--]='\0';//消除后面的空格
    char* rt=(char*)malloc(n*sizeof(char));
    char* stk=(char*)malloc(n*sizeof(char));
    int i=n,t=0,cnt=0;
    // printf("i=%d\n",i);//16
    // printf("s[i]=%c\n",s[i]);//e

    while (i>=0) {
        while (s[i] != ' ') stk[t++]=s[i--];
        while (t>0) rt[cnt++]=stk[--t];
        rt[cnt++]=' ';
        while (s[--i] == ' ');
        //printf("i=%d\n",i);
    }

    return rt;
}

int main(void) {
    // char s1[]="123456";
    // char s2[]="13452439";
    // St st=maxStr(s1,s2);
    // printf("---------\n");
    // printf("beg=%d\n",st.beg);
    // printf("len=%d\n",st.len);
    // for (int i=st.beg;i<st.beg+st.len;++i) {
    //     printf("%c",s1[i]);
    // }
    // printf("\n");

    char str[]="  the   sky  is   blue  ";
    char* rt=reverseWords(str);
    printf("rt=%s\n",rt);
    
    // char s1[]="123";
    // printf("len=%lu\n",strlen(s1));//3

    return 0;
}
*/



//09 树和二叉树：分支关系与层次结构下，如何有效实现增删查？
//9.1 树是什么
//描述这棵树中节点的位置
//(1)层次: 从根结点算起，根为第一层，根的“孩子”为第二层
//(2)深度(高度): 最大层次数

//9.2 二叉树是什么
//特殊的树，各节点最多有两个字节点。
//9.2.1 两个特殊的类型
//(1)满二叉树: 除了叶子结点，所有结点都有 2 个子结点
//(2)完全二叉树: 除了最后一层，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列
//9.2.2 存储二叉树2种办法
//(1)链式存储: 各节点有3个字段，一个存数据，另外两个存放左右子结点的指针
//(2)顺序存储: 数组，根节点在下标为1的位置，按照层次遍历依次存放到数组。
//下标为i的节点，其左子节点下标为2*i, 右子节点下标为2*i+1
//完全二叉树: 存储空间利用效率高，仅浪费下标为0的位置。

//9.3 树的基本操作
//树结构是“一对多”的关系，即父结点，跟若干个子节点有连接关系
//9.3.1 树的遍历
//前序: 根左右
//中序: 左根右
//后序: 左右根
//(1)各节点都被访问一次，时间复杂度O(n)
//(2)增加和删除操作的时间复杂度O(1)
//(3)查找需要遍历每一个数据去判断, 时间复杂度O(n)

typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
}TN;

void PreOrder(TN* p) {
    if (p==NULL) return;
    printf("%d ",p->data);
    PreOrder(p->left);
    PreOrder(p->right);
}

void MidOrder(TN* p) {
    if (p==NULL) return;
    MidOrder(p->left);
    printf("%d ",p->data);
    MidOrder(p->right);
}

void PostOrder(TN* p) {
    if (p==NULL) return;
    PostOrder(p->left);
    PostOrder(p->right);
    printf("%d ",p->data);
}

//9.3.2 二叉查找树的特性
//当二叉树具备一些特性时，则可利用这些特性降低时间复杂度
//二叉查找/搜索树，具备的特性:
//(1)二叉查找树中任意一个节点，左子树中各节点的值，都 < 此节点值
//(2)二叉查找树中任意一个节点，左子树中各节点的值，都 > 此节点值
//(3)尽可能规避两个结点数值相等
//(4)中序遍历, 从小到大的有序数据

//9.3.3 查找
//(1)root.data == key ? return : (2)
//(2)root.data >  key ? 在左子树中递归执行查找动作，直到叶子结点。
//(3)root.data <  key ? 在右子树中递归执行查找动作，直到叶子结点。
//这样的“二分查找”时间复杂度O(log(n))

//9.3.4 插入
//从根结点开始，判断要插入的数据与该节点的大小，决定在左子树还是右子树中插入数据。
//时间复杂度O(log(n)): 更多消耗在遍历数据去找到查找位置上，真正执行插入的时间复杂度是O(1)

//9.3.5 删除
//(1)删除叶子节点，则直接删除，其父结点指针指向NULL
//(2)该节点只有一个子节点，将其父结点指向的子结点的指针 换成 其子节点的指针
//(3)要删除的节点有两个子节点
//1)找到该节点的左子树中最大节点，替换要删除的节点
//2)找到该节点的右子树中最小节点，替换要删除的节点

//9.3.6 树的案例
//输入一个字符串，判断它在已有的字符串集合中是否出现过?
//对字符串建立一个树结构，合并字符串集合的前缀，各根节点到叶子结点的链条就是一个字符串。
//这个树结构称作 Trie树/字典树。有3个特点:
//(1)根节点不含字符
//(2)除根节点，各节点都含1个字符
//(3)根节点到叶子节点，路径上的字符连接起来，即为集合中的某个字符串
//问题的解法可拆解为2个步骤:
//(1)根据候选字符串集合，建立字典树。这需要使用数据插入的动作。
//(2)对于一个输入字符串，判断它能否在这个树结构中走到叶子结点. 如果能，则出现过。

//9.4 总结
//树结构在存在“一对多”的数据关系中，可被高频使用，这是它区别于链表系列数据结构的关键点。

//9.5 练习题
//层次顺序遍历并打印这棵树



//10 哈希表：如何利用好高效率查找的“利器”？
//线性表、数组、字符串和树, 各有千秋:
//(1) 线性表中的栈和队列对增删有严格要求，它们会更关注数据的顺序。
//(2) 数组和字符串需要保持数据类型的统一，并且在基于索引的查找上会更有优势。
//(3) 树的优势则体现在数据的层次结构上。
//缺陷: 数据数值条件的查找，需要对全部/部分数据进行遍历。

//10.1 什么是哈希表(散列表)
//一种特殊的数据结构, 有很明显的区别。
//10.1.1 哈希表的核心思想
//采用函数映射的思想, 将存储位置与关键字关联起来 --> 能够快速定位到想要查找的数值
//数组的局限性: 只能基于数据的索引，不能基于数据的数值去查找。
//核心思想: 实现“地址 = f(关键字)”的映射关系，就可快速完成基于数值的查找

//10.1.2 如何设计哈希函数
// Hash函数设计的好坏会直接影响到对哈希表的操作效率。
//(1)直接定制法
//哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。
//(2)数字分析法
//每个关键字key都是由s位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。
//(3)平方取中法
//关键字的每一位都有某些数字高频重复出现，先求关键字的平方值，平方扩大差异，然后取中间几位作为最终存储地址
//(4)折叠法
//关键字的位数很多，可将关键字分割为几个等长部分，取它们叠加和的值（舍去进位）作为哈希地址。
//(5)除留余数法
//预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p

//10.1.3 如何解决哈希冲突
//本质上，哈希冲突只能尽可能减少，不能完全避免。
//因为，输入数据的关键字是个开放集合。只要输入的数据量够多、分布够广，就完全可能发生冲突
//因此，哈希表需要设计合理的哈希函数，并且对冲突有一套处理机制。
//(1)开放定址法
//发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，沿着此探测序列依次查找下去。当碰到一个空的单元时，则插入其中。
//常用的探测方法是线性探测法。
//(2)链地址法
//将哈希地址相同的记录存储在一张线性链表中。
//
//哈希表优势:
//(1)插入和删除: 接近常量时间,无论多少数据
//(2)查找: 比树还要快
//不足:
//(1)哈希表中的数据没有顺序概念, 不能以一种固定的方式来遍历其中的元素
//在数据处理顺序敏感的问题时, 不是好的处理方法
//(2)哈希表中的 key 是不允许重复
//在重复性非常高的数据中，哈希表也不是好的选择

//10.2 哈希表的基本操作
//很多高级语言中，哈希函数、哈希冲突都已经在底层完成了黑盒化处理
//哈希表完成了关键字到地址的映射，可在常数级时间复杂度内, 通过关键字查找到数据。
//(1)增加和删除，不涉及增删后对数据的挪移（数组需要考虑）
//(2)查找的细节过程: 给定key，通过哈希函数计算哈希地址 H(key)
//如果哈希地址对应的值为空，则查找不成功。
//反之，则查找成功。

//10.3 哈希表的案例
//10.3.1 将关键字序列 {7, 8, 30, 11, 18, 9, 14} 存储到哈希表中。哈希函数为： H (key) = (key * 3) % 7，处理冲突采用线性探测法。
//10.3.2
//有一个在线系统，可实时接收用户提交的字符串型关键字，并实时返回给用户累积至今这个关键字被提交的次数。
//预先定义好哈希表后, 对于关键字, 判断 d 中是否存在 key_str 的记录

//10.4 总结
//(1)查找、插入、删除只需接近常量的时间, 不论哈希表中有多少数据
//(2)如果不需要有序遍历，并且可提前预测数据量大小。那么哈希表在速度和易用性方面是无与伦比的。

//10.5 练习题
//给定一个整数数组 arr 和一个目标值 target，请你在该数组中找出加和等于目标值的那两个整数，并返回它们的在数组中下标。
//用哈希表提高效率。

























































