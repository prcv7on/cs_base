

#include <iostream>
#include <string>

//#include "singleList.h"
//#include "DoubleList.h"
//#include "array_stack.h"
//#include "list_stack.h"
//#include "cycle_queue.h"
//#include "list_queue.h"
//#include "binary_search_tree.h"
#include "max_heap.h"
//#include "min_heap.h"

using namespace std;


//--------- C语言与C++编程---------

//1 数据结构图文解析之: 数组、单链表、双链表介绍及C++模板实现
//1.1 线性表简介
//线性表是一种线性结构，它是由>=0个数据元素构成的有限序列。特征: 除首尾元素，各元素有且只有一个直接前驱，一个直接后继; 首元素无直接前驱，尾元素无直接后继
//数据结构中常见的线性结构： 数组、单链表、双链表、循环链表等。
//线性表中的元素: 某种相同的抽象数据类型。C的内置类型或结构体，或C++自定义类型
//
//1.2 数组
//(1) 数组在实际物理内存上连续存储，有上界和下界
//数组下标从0开始，a[0]对应首元素。a[0]数组a的下界，a[6]数组a的上届。超过这个范围的下标使用数组，将造成数组越界错误。
//(2) 数组特点: 数据连续，支持快速随机访问。
//(3) 数组分为固定数组与动态数组。其中固定数组的大小必须在编译能够确认，动态数组允许在运行时申请数组内存。
//多维数组: 通过一维数组实现。C通过malloc分配动态数组，C++使用new。另外，C++的标准模板库提供了动态数组类型vector以及内置有固定数组类型array。
//
//1.3 单向链表
//链表的一种。链表由节点构成，节点内包含指向后继节点的指针，节点依次链接成为链表。因此，链表在物理内存上不连续。链表通常含有一个头节点，头节点不存放实际的值，它含有一个指针，指向存放元素的第一个节点。
//1.3.1 单向链表的节点结构
//1.3.2 单向链表的抽象数据结构
//1.3.3 单链表添加节点 --> 链表插入元素: 时间复杂度O(1)，只需修改指针的指向
//1.3.4 单链表删除节点 --> 删除: 时间复杂度O(1)，只需修改节点指针的指针向后, 即可销毁被删除节点。
//1.3.5 单链表代码测试
//
//1.4  双向链表
//单链表的节点链接是单方向，要得到指定节点的前驱，必须从头遍历
//是链表的一种。双向节点由节点链接而成，各节点有两个指针，分别指向直接前驱与直接后继。从双向链表的任何一个节点开始， 都能遍历整个链表
//将双向链表实现为双向循环链表，即， 尾元素的后继指向头节点，整个链表形成一个循环
//1.4.1 双向链表节点结构 --> 比单向链表多一个指向直接前驱的指针
//1.4.2 双向链表的抽象数据结构 --> 双向链表类的定义与单链表相似
//1.4.3 双向链表添加节点 --> 时间复杂度O(1)，只需修改指针的指向
//1.4.4 双向链表删除节点 --> 时间复杂度O(1)
//1.4.5 双向链表代码测试


/*
int main(void) {
	//SingleList<int> sList;
	//for (int i = 0; i < 10; ++i) {
	//	sList.insert(i,i);
	//}
	//cout << "sz=" << sList.size() << "\n";
	//sList.insert_head(12);
	//sList.insert_tail(99);
	//sList.print();

	DoubleList<int> dList;
	for (int i = 0; i < 10; ++i) {
		dList.insert(0,i+10);
	}
	dList.insert(0,100);
	dList.insert_tail(1000);
	dList.print();//100<->19<->18<->17<->16<->15<->14<->13<->12<->11<->10<->1000<->phead......
	cout << "sz=" << dList.size() << "\n";

	dList.del_front();
	dList.del_tail();
	dList.print();//19<->18<->17<->16<->15<->14<->13<->12<->11<->10<->phead......
	dList.del(3);
	dList.print();//19<->18<->17<->15<->14<->13<->12<->11<->10<->phead......

	getchar();
	return 0;
}
*/


//2 数据结构图文解析之：栈的简介及C++模板实现
//2.1 栈的简介
//2.1.1 栈的特点
//栈(Stack)是一种线性存储结构，特点:
//(1) 栈中的数据元素遵守"先进后出"(First In Last Out)原则，简称FILO
//(2) 限定: 只能在栈顶插入和删除
//2.1.2 栈的相关概念
//(1) 栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。
//(2) 插入: 进栈、压栈、入栈。--> 压栈过程中，栈顶位置一直"向上"移动，栈底固定不变
//(3) 弹栈: 栈的删除操作，出栈。--> 弹栈过程中，栈顶位置一直"向下"移动，栈底保持不变
//2.1.3 栈的操作
//1、弹栈，pop
//2、压栈，push
//3、求栈的大小
//4、判断栈是否为空
//5、获取栈顶元素的值
//2.1.4 栈的存储结构
//栈是线性结构，能以数组或链表（单向、双向或循环链表）作为底层数据结构。
//
//2.2 基于数组的栈实现
//以数组为底层数据结构时，数组头为栈底，数组头到数组尾为栈顶的生长方向
//2.2.1 栈的抽象数据类型
//2.2.2 栈的具体实现
//
//2.3 基于单链表的栈
//以链表为底层的数据结构时，链表头为栈顶，方便节点的插入与删除。压栈产生的新节点一直在链表头
//2.3.1 链表节点
//2.3.2 栈的抽象数据类型 --> 基于链表的栈,与基于数组的栈, 提供的接口一致。
//2.3.3 栈的具体实现
//2.3.4 栈的代码测试


/*
int main(void) {
	//ArrayStack<int> stk(5);
	//for (int i = 0; i < 5; ++i) {
	//	stk.push(i+10);
	//}
	//cout << "size=" << stk.size() << "\n";//5
	//cout << "empty=" << stk.isEmpty() << "\n";//0
	//cout << "top=" << stk.top() << "\n";//14
	//stk.print();//14 13 12 11 10

	ListStack<string> lstk;
	lstk.push("hello");
	lstk.push("my");
	lstk.push("friend.");
	cout << "sz=" << lstk.size() << "\n";//3
	cout << "top=" << lstk.top() << "\n";//friend
	lstk.print();
	cout << "sz=" << lstk.size() << "\n";//0

	getchar();
	return 0;
}
*/


//3 数据结构图文解析之：队列详解与C++模板实现
//3.1 队列简介
//3.1.1 队列的特点
//队列Queue与栈一样，是线性存储结构，特点:
//队列元素遵循"先进先出"（First In First Out）原则，简称FIFO  --> 在队尾添加元素，在队头删除元素。
//
//3.1.2 队列的相关概念
//队头与队尾: 元素插入的一端称为队尾，元素删除的一端称为队头。
//入队: 队列的插入。添加元素只能从队尾入队
//出队: 队列的删除。元素只能从队首出队列，顺序为：1、2、3，与入队时的顺序一致，这就是"先进先出"
//3.1.3 队列的操作
//入队: push()
//出队: pop()
//求队列中元素个数
//判断队列是否为空
//获取队首元素
//3.1.4 队列的存储结构
//队列与栈都是线性结构，线性表如数组、链表作为底层数据结构
//本文以数组、链表为底层数据结构构建队列。
//
//3.2 基于数组的循环队列
//以数组作为底层数据结构，实现为循环队列。队列顺序存储的不足: 每次从数组头部删除元素（出队）后，需将头部后的所有元素往前移动一个位置，时间复杂度为O(n)
//希望: 队列的插入与删除都是O(1)时间复杂度，同时不会造成数组空间浪费 --> 应使用循环队列
//循环队列: 可把数组看作一个首尾相连的圆环，删除元素时将队首标志后移，添加元素时若数组尾部没有空间，则考虑数组头部是否空闲，如果是，则在数组头部插入
//如何判断队列是否空？
//栈空: 队首标志 = 队尾标志，即红绿两个标志在图中重叠时为栈空。
//栈满: 队尾 + 1 = 队首。图三最下面的队列即为一个满队列。尽管还有一个空位，不存储元素。
//3.2.1 循环队列的抽象数据类型
//3.2.2 队列的具体实现
//3.2.3 循环队列代码测试
//
//3.3 链队列
//基于链表实现，不存在数组O(n)的元素移动或空间浪费问题。要确定的是链表哪头做队首，哪头做队尾。
//显然应以链表头部为队首，链表尾部为队尾。存储一个指向队尾的指针，方便从链表尾插入元素；使用带头节点的链表，方便从链表头删除元素。
//3.3.1 链表节点
//3.3.2 队列的抽象数据类型
//3.3.3 队列的具体实现
//3.3.4 队列的代码测试

/*
int main(void) {
	//CycleQueue<string> cq(6);
	//cq.push("one");
	//cq.push("two");
	//cq.push("three");
	//cq.push("four");
	//cq.push("five");
	//cout << "sz=" << cq.size() << "\n";
	//cq.print();

	ListQueue<string> lq;
	lq.push("one");
	lq.push("two");
	lq.push("three");
	lq.push("four");
	lq.push("five");
	cout << "sz=" << lq.size() << "\n";
	lq.print();

	getchar();
	return 0;
}
*/


//4 数据结构图文解析之：树的简介及二叉排序树C++模板实现.
//4.1 树的简介
//4.1.1 树的特征
//树是一种数据结构，它是n(n>=0)个节点的有限集。n=0称为空树。n>0，有限集的元素构成一个具有层次感的数据结构。
//区别于线性表一对一的元素关系，树中的节点是一对多。特点:
//n>0时，根节点唯一，不可能存在多个根节点。
//每个节点有>=0个子节点; 除根节点，各节点有且仅有一个父节点。
//4.1.2 树的相关概念
//(1) 子树: 除根节点外，各子节点都可分为多个不相交的子树
//(2) 孩子与双亲：若一个结点有子树，那么该结点称为子树根的"双亲"，子树的根是该结点的"孩子"。在图一中，B、H是A的孩子，A是B、H的双亲。
//(3) 兄弟: 具有相同双亲的节点
//(4) 节点的度: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3.
//(5) 叶子: 没有子树，度为0的节点。
//(6) 分支节点: 除叶子节点之外的节点，度不为0的节点。
//(7) 内部节点: 除根节点之外的分支节点。
//(8) 层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.
//(9) 树的高度: 树的深度，树中节点的最大层次。
//(10) 有序树: 树中节点各子树间的次序重要，不可随意交换位置。
//(11) 无序树: 树中节点各子树间的次序不重要。可随意交换位置。
//(12) 森林: 0或多棵互不相交的树的集合。

//4.2 二叉树简介
//4.2.1 二叉树的定义
//二叉树或为空集，或由一个根节点和两棵互不相交的、分别称为左子树和右子树的二叉树组成。从定义可知:
//(1) 二叉树是有序树，区分左子树与右子树，不可随意交换子树位置
//(2) 一个节点的子树数量为0，1，2。0: 叶子节点，1: 只有左子树或只有右子树，2: 有左右子树。
//根据定义，一棵二叉树有5中基本形态.
//4.2.2 斜树、满二叉树、完全二叉树、二叉查找树
//(1) 斜树
//所有节点都只有左(右)子树的二叉树叫做左(右)斜树。左斜树和右子树统称为斜树。
//斜树已退化成线性结构，二叉树在查找上的优异性能， 在斜树得不到体现。
//(2) 满二叉树
//满二叉树要满足两个条件: --> 所有节点同时具有左右子树, 所有叶子节点在同一层上
//在同样深度的二叉树中，满二叉树的节点数最多，叶子数最多
//(3) 完全二叉树
//在一棵二叉树中，只有最下两层的度可小于2，并且最下层的叶子节点集中在靠左的若干位置
//或者这样定义: 对具有n个节点的二叉树按层序从左到右编序，二叉树树某个节点的编序与同样位置的满二叉树节点的编序相同. 若所有节点都满足此条件，则二叉树为完全二叉树。
//从定义可知: 满二叉树一定是完全二叉树；完全二叉树不一定是满二叉树。
//(4) 二叉查找树
//二叉排序树也称为二叉搜索，排序树。二叉排序树的节点包含键值key。二叉排序树或是一棵空树，否则要求:
//若它的左子树不为空，那么左子树上所有节点的key都<根节点的key
//若它的右子树不为空，那么右子树上所有节点的key都>根节点的key
//它的左右子树也分别为二叉排序树
//根据定义，二叉查找树中无重复key的节点。
//4.2.3 二叉树的性质
//性质一: 在二叉树的第i层上至多有2 ^ (i - 1)个节点(i >= 1)
//性质二: 深度为k的二叉树至多有2^k - 1个节点
//性质三: 对任何一棵二叉树T，如果终端节点数为n0，度为2的节点数为n2 ，那么 n0 = n2 + 1
//性质四: 具有n个节点的完全二叉树的高度为至少为log2(n + 1)
//性质五: 如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开始到最下一层，每一层从左到右编号），对任一节点i有：

//4.3 二叉查找树
//二叉查找树的定义我们已经知道。要维护二叉查找树的特性，删除节点比较复杂，将重点解析。先来看看二叉查找树的节点结构定义与类定义。
//4.3.1 节点结构
//4.3.2 二叉查找树的抽象数据结构
//4.3.3 插入新节点步骤：
//寻找元素合适的插入位置：新元素与当前结点进行比较，若值大于当前结点，则从右子树进行寻找；否则从左子树进行寻找.
//找到插入位置之后，以元素的值构建新节点，插入二叉排序树中
//4.3.4 遍历平衡二叉树
//遍历平衡二叉树，就是以某种方式逐个“访问”二叉树的每一个节点。“访问”是指对节点的进行某种操作，例如输出节点的值。
//平衡二叉树是有序树，严格区分左子树与右子树，如果规定左子树先于右子树的次序，我们有三种方式遍历二叉树：
//前序遍历
//中序遍历 对于一棵二叉排序树，中序遍历时刚好可以输出一个非递减的序列。
//后序遍历
//4.3.5 前驱与后继
//(1) 前驱节点有3种情况:
//有左子树，则前驱节点为左子树最右节点
//无左子树，且本身为右子树，则前驱节点为其父节点
//无左子树，且本身为左子树，则前驱节点为"第一个拥有右子树的父节点"
//(2) 后继节点有3种情况:
//有右子树；则后继节点为右子树最左节点
//无右子树，但本身是左孩子，则后继节点为其父节点
//无右子树，但本身是右孩子，则后继节点为"第一个拥有左子树的父节点"
//4.3.6 删除节点
//删除二叉排序树的某个节点有3种情况:
//(1) 被删除节点同时有左子树与右子树 --> 将前驱节点的值保存在当前结点，继而删除前驱节点。
//(2) 被删除节点只有左(右)子树 --> 直接用子树替换被删节点
//(3) 被删除节点无子树 --> 直接删除节点
//4.3.7 查找元素
//递归或非递归地查找。与插入过程一致，不断与当前结点比较，若>当前节点的值，在右子树查找，若<当前节点的值，在左子树查找，适合递归。由于二叉排序树特征: 左小右大，容易进行非递归查找
//4.3.8 查找最值元素
//二叉排序树的最小值位于其最左节点. 最大值位于其最右节点
//4.3.9 销毁二叉树
//使用后序遍历递归销毁二叉树

/*
int main(void) {
	BSTree<int> t;
	t.insert(62);
	t.insert(58);
	t.insert(47);
	t.insert(51);
	t.insert(35);
	t.insert(37);
	t.insert(88);
	t.insert(73);
	t.insert(99);
	t.insert(93);
	t.insert(95);
	cout << "mid_order: \n";
	t.midOrder(); 
	cout << "\n";
	cout << "min=" << t.search_min() << "\n";
	cout << "max=" << t.search_max() << "\n";

	cout << "remove 99.\n";
	t.remove(99);
	cout << "max=" << t.search_max() << "\n";
	t.destory();

	getchar();
	return 0;
}
*/


//5 数据结构图文解析之：二叉堆详解及C++模板实现
//5.1 二叉堆的定义
//二叉堆是一种特殊的堆，二叉堆是(近似)完全二叉树。满足堆特性: 父节点与所有子节点的键值保持固定关系，且各节点的左(右)子树都是二叉堆
//最大堆: 父节点键值>=所有子节点键值。 最小堆: 父节点键值<=所有子节点键值。
//5.2 二叉堆的存储
//数组。数组的随机存储能力 --> 能很快确定堆中节点的父节点与子节点。
//本文大顶堆的根节点位置为0.
//5.3 二叉堆的具体实现
//(1) 注意capacity与size的区别。capacity: 数组的固有大小。size: 数组中有效元素个数，有效元素为组成堆的元素。
//(2) heap为数组。
//5.3.1 二叉堆的抽象数据类型
//5.3.2 二叉堆的插入
//在数组末尾插入新节点，然后自下而上调整子与父节点的位置: 比较当前结点与父节点的大小，若不满足大顶堆性质，则交换两节点。时间复杂度O(logn)
//真正编程时，为了效率不必交换节点，直接用父节点的值覆盖子节点。最后把新节点插入它最后的位置
//5.3.3 二叉堆的删除
//用数组最末尾节点覆盖被删节点，再从该节点从上到下调整二叉堆。
//5.3.4 其余操作

/*
int main(void) {
	MaxHeap<int> heap1(11);
	for (int i = 0; i < 10; ++i) {
		heap1.insert(i);
	}
	heap1.print(); cout << "\n";//9 8 5 6 7 1 4 0 3 2
	heap1.remove(8);
	heap1.print(); cout << "\n";//9 7 5 6 2 1 4 0 3

	MaxHeap<int> heap2(11);
	int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	heap2.createMaxHeap(a,10);
	heap2.print(); cout << "\n";//10 9 6 7 8 2 5 1 4 3

	//MinHeap<int> heap1(11);
	//for (int i = 0; i < 10; ++i) {
	//	heap1.insert(i);
	//}
	//heap1.print(); cout << "\n";//0 1 2 3 4 5 6 7 8 9
	//heap1.remove(8);
	//heap1.print(); cout << "\n";//0 1 2 3 4 5 6 7 9

	//MinHeap<int> heap2(11);
	//int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//heap2.createMinHeap(a,10);
	//heap2.print(); cout << "\n";//1 2 3 4 5 6 7 8 9 10

	getchar();
	return 0;
}
*/










































































































































































































































































































































