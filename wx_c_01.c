

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// ---------编程剑谱---------
//1为什么建议大家一定的会 C 语言
//扎实的基础功底很重要，基础是什么：数据结构 + 算法，操作系统 + 计算机网络，Linux + C，数据库 + 设计模式
//C 语言能够让你更加深刻的认识内存和编译原理，了解程序的每一个细节，夯实基本功，站得“低”才能望的远

//2 入门篇
//C 程序的几个特点：
//(1) main()主函数：一个独立的、完整的、正确的 C 语言程序，有且仅有一个主函数，主函数是整个程序的入口，无论将其书写在什么地方
//(2) ；：分号是 C 语言语句结尾的标志，如果没有这个分号，只能形成表达式，单独的一个分号，也是语句，叫做：空语句
//(3) {}：花括号，表示的是一段程序，是 C 语言程序块、函数体的起止标志
//(4) C 语言是一个大小写 “敏感” 的语言，即，C 语言严格区分大小写

//3 常量和变量
//3.1 常量
//整型（int、short、long）
//浮点型（float、double）
//字符常量
//字符串常量：在" "里所表达的都是字符串常量

//ASCII码知识普及：
//(1) 字符，通过点阵矩阵存储（一个英文字符对应一个点阵），占2 字节
//(2) 对英文字符的点阵信息使用一个字节的低 7 位进行编号，这个编号就叫做：ASCII 码
//(3) ASCII 码 就是字符所对应的编号，看到 ASCII 码就等价于这个编号（数字），字符即数字
//字符零：'0' == > 48
//零：0 == > 0 == >'\0'，这个是真正的 0
//(4) 字符或是字符串的大小比较，其实是ASCII码比较
//(5) 全角和半角：全角实质上是中文点阵，占2字节，半角是英文点阵，即ASCII 码，占1字节，C只用英文标点

//计算机中，对字符的管理，是通过编号进行的，编号的三个原则：
//A、从 0 开始编号
//B、连续编号
//C、用二进制编号

//3.2 变量
//本质：内存中一段连续的存储空间
//对于内存的理解：
//(1) 内存是由多个字节组成的一维、线性、连续存储空间
//(2) 字节是内存分配存储空间的基本单位
//(3) 对于内存中的多个字节，通过对字节(内存空间 1B)唯一性的编号来管理
//(4) 参与字节编号的二进制位数，--> 计算机能管理的内存大小

//变量的三个要素：
//变量名称：变量都是英文名，见名知意
//命名原则：
//(1) 必须以字母或者下划线(_)开头
//(2) 只能由字母、数字、下划线字符组成
//(3) 不能使用 "关键字" / 起名
//(4) C 语言区分大小写

//变量类型：决定所占字节数
//变量的值：变量运算后，得到的结果
//定义变量的本质：申请存储空间，类型在定义时被确定，终生不变

//4 数据类型及运算符
//4.1 数据类型
//数据类型有 2 个关键要素:识别方式和长度. 两者必须明确指出，有一个不确定，则不能形成有效的数据类型
//C 语言中的数据类型(64位):
//标识符  长度  名称         识别方式
//char     1B   字符型       ASCII码
//short    2B   短整型       补码
//int       4B    整型         补码
//long     8B   长整型       浮点
//float     4B   单精度       浮点
//double  8B   双精度       浮点
//* 8B   地址、指针  字节编号

//4.2 运算符
//4.2.1 算术运算符:优先级由高到低：
//() + / -(正 / 负号)     *， / ，%     +， -
//4.2.2 关系运算符:运算结果：只有1(真)0(假). 优先级低于算术
//4.2.3 逻辑运算符:!,&& ,||
//4.2.4 赋值运算符:不能对常量或表达式赋值.
//本质：覆盖原值
// += ,-=,*=,/=,%=，仅比,运算符优先级高
//++、--：本质是赋值运算符
//4.2.5 三目运算符:条表 ? 表1 : 表2 --> 表达式结果，为真执行表 1，为假执行表 2
//4.2.6 逗号运算符:优先级最低
//用来分隔多个表达式，运算结果：最后一个表达式的运算结果

//5 补充四个问题
//5.1 运算符优先级的问题：
//(1) 一次只比较两个相邻运算符
//(2) 一次只处理相邻两个运算符中的一个
//(3) 当前运算符是否运算，取决于与相邻运算符的优先级比较：“低于”其后的运算符，不运算，
//
//5.2 数据类型转换
//5.2.1 自动
//参加运算的类型不一样，C会对其自动类型转换,原则如下：
//短类型-->长类型，简单类型-->复杂类型
//char-->short-->int-->float-->double
//
//5.2.2 强制
//语法：(数据类型名称)表达式
//source = (double)1 / 5     //其结果就是double类型
//强制类型转换：仅是对此变量的值进行转换，是单目运算符中优先级最低的
//
//5.3 短路运算
//逻辑运算中的0、1铁律：
//0 && A == >  0、1  &&  A == >  A
//0 || A == >  A、1 || A == >  1
//短路运算仅发生在逻辑运算表达式
//在 && 运算符左侧表达式为 0，或||左侧非 0 ，此时结果已定，C会短路运算，不运算右侧表达式
//
//5.4 关于输入 / 输出函数
//(1) 输入、输出通过 printf() scanf() 函数实现的
//(2) 格式符是决定数值以什么方式展现
//(3) 在scanf()函数的" "中，除了写格式符之外，不写其它，"%d%s%c"即可

//6 结构化程序设计
//6.1 三种结构
//模块化程序的特点：单入口、单出口
//顺序结构、分支结构（选择结构）、循环结构，这三种结构基本上构成了模块的框架
//6.1.1 顺序结构
//6.1.2 选择结构
//6.1.3 循环结构: 循环三要素：初值、条件、步长，必须明确
//一定要以技术的深度为主，熟练的掌握一门，编程思想到位了，其他都不是问题，再将技术进行横向的扩展，由易入难，由深入广的打法

//6.2 三步走战略
//三步走：输入 + 处理 + 输出
//三步走：分而治之 + 变量跟踪 + 换位思考
//能力的提升才是你的资本.要学的是怎么思考，怎么分析，怎么取实现，把这些能力提升起来

//6.3 编程实践
//对于要实现的相关程序，必须自己动手
//再手工实现的过程中，去寻找、概况、总结在这过程中的一般性规律，而程序就是对这个规律的精准描述

//6.4 说在最后
//人生需要布局，需要大的战略，冲破现状，真正的成长起来

//7 数组
//7.1 简单理解数组
//(1) 为什么要有数组？
//数组：多个内存变量元素，使用同一个变量名称，并用下标区分
//必需先定义，再使用
//定义数组时，[] 里的内容必须是正整数
//(2) 理解数组定义
//(3) 数组元素的使用

//7.2 数组内存分布
//C 编译软件不能发现“下标越界”错误.
//“下标越界”错误,完全靠程序员避免！

//7.3 数组常见操作
//7.3.1 数组元素的遍历
//对于数组元素，进行不重复、无遗漏的一次性访问
//数据存储在数组中需要满足的 3 个条件：
//(1) 从下标为 0 的第一个元素（首元素）开始存放
//(2) 连续存放
//(3) 上述两个特点必须动态满足（即：删除，插入数据，在删除或插入数据后，依要满足上述两个基本条件）
//7.3.2 数组赋初值
//数组赋初值仅能发生在定义语句未结束时！
//int a[5] = { 1, 2, 3 };//1 2 3 0 0
//int a[] = { 1, 2, 3, 4, 5, 6, 7 }; //定义数组，不明确声明数组元素个数，但赋初值；则，数组元素个数取决于初值个数

//7.4 二维数组
//内存是一维，线性管理的

//7.5 字符数组与字符串
//7.5.1 字符串
//以 0 结束的字符数组（这里的 0，就是数字 0，不是字符零 '0'，其ASCII 码值为 48）
//char s[5] = { 'A', 'B', 'C', 'D', 'E' }; //字符数组
//char s[5] = { 'A', 'B', 'C', 'D', '0' }; //字符数组
//char s[5] = { 'A', 'B', 'C', 'D', 0 }; //字符串
//char s[5] = "ABCD"; //字符串
//char s[5] = { 'A', 'B', 'C', 'D' }; //字符串
//7.5.2 运算符：sizeof()
//sizeof(数据类型名称)
//sizeof(变量名称或数组名称)
//sizeof(字符串常量) == 字符串长度+1
//7.5.3 strlen()函数：计算字符串长度
//printf("%d\n", strlen("abcdefg"));  //结果为7
//对于字符串的处理：遇 0 则止（调用字符串函数）

//8 指针
//学习的顺序是这样的：数组--->指针--->函数
//8.1 基本概念
//8.1.1 指针有两个要素
//(1) 首地址：内存中多个连续字节的首字节地址
//(2) 所指空间的数据类型
//8.1.2 指针类与值类
//int、float 等等都统称为值类。
//8.1.3 指针的基本运算
//&左值（左值只能是空间、变量），取内存地址
//&常量和&表达式,语法错误
//* 运算符: 与 & 优先级相同，和 & 互为逆运算
//语法：*指针（常量、变量、表达式）
//8.1.4 指针定义的理解
//8.1.5 指针的加减运算
//指针+ -整型: 步长==sizeof(数据类型)
//相同类型，指针相减 = > int 类型(元素个数)

//8.2 指针与数组
//8.2.1 指针与一维数组
//数组名称的本质：数组首地址常量。
//数组名称是常量
//数组名称是首地址（指针），可参加指针能参与的所有运算
//a[i] == *(a + i)
//8.2.2 指针与二维数组

//8.3 指针与字符串
//8.3.1 字符串常量的本质：是该字符串的首地址常量，即指针常量。
//8.3.2 字符串常量的本质是指针常量，可参加指针能参与的所有运算
//字符串常量不能更改其内容。
//字符串本质是字符数组，数组名称本质是指针常量；

//8.4 字符串类处理函数
//8.4.1 对于 scanf("%s"...) 和 gets() 的理解
//strlen(): 将其唯一的参数当成首地址，从这个首地址所指向的空间开始，统计所有字符的个数，直到遇到0（结束标志）。
//8.4.2 字符串输入、输出函数
//输入：scanf("%s", ...)、gets(...)
//输出：printf("%s", ...)、puts(...)
//char *strcpy(char *target, char *source);
//char *strcat(char *, char *);
//char *strstr(char *string, char *subString);
//int strcmp(char *s1, char *s2);
//char *strrev(char *);

//9 函数
//9.1 基本概念
//函数的产生和使用过程
//9.1.1 函数声明
//函数名称，以区分其它函数，是此函数的”入口“地址常量。
//函数的返回值类型，最多只能有一个返回值
//函数的参数个数及类型；声明函数时，可只说明参数类型，缺省相关变量。

//9.1.2 函数定义
//(1) 函数首部：返回值类型、函数名称、形参；
//(2) 函数体：由{} 括起来的语句组成。
//(3) 返回值void，可写 return; 语句结束，也可缺省
//return 表达式; 表达式类型必须与返回值类型完全一致
//(4)关于 return
//它是函数运行结束的语句，该语句后的任何其它语句，不会运行
// return(返回)，是“返回”到调用它的函数的下一条语句继续执行。
//return 表达式; 返回到主调函数，并用“表达式”的值，替代主调函数中，该函数的调用部分

//9.1.3 函数调用

//9.2 形参与实参
//9.2.1 定义
//(1) 形参出现在函数定义的“函数首部”的括号中；
//(2) 实参出现在函数调用的括号中；
//(3) 实参有三种形式：常量、变量、表达式；
//(4) 形参只有一种形式：变量。
//9.2.2 关系
//(1) 个数一致；
//(2) 按位置关系必须对应；
//(3) 数据类型必须一致；
//(4) 值传递 --> 将实参表达式的值，复制一份，赋值给形参变量！
//9.2.3 私有变量
//函数体中定义的变量，以及该函数的所有形参变量
//函数只能使用、调用本函数的私有变量和“公有变量”，不能直接使用其它函数的私有变量
//私有变量是在定义这个变量的函数被调用时，才申请存储空间。与其它函数的私有变量的空间，是没有任何关系
//私有变量将随着定义它的函数的运行结束，而释放其空间。

//9.2.4 形参不能修改实参的值
//C 语言中，“指针”存在的理由：
//最核心原因：C函数语言，没有过程概念，指针传变量地址，才能修改变量

//9.3 C函数特点
//高度的独立性：任何函数只能引用属于自己的私有变量和全局变量
//函数返回值最多只有一个
//C 语言函数中，只有一种：值传递
//C 函数是无法实现：“同时更改主调函数中多个私有变量的值”的功能！

//指针的概念，就是为了解决上述 C 语言“致命”问题而提出来的！
//将需要更改的变量(空间)的首地址作为实参；
//被调函数对应的形参变量必须是上述变量的指针类型进行接收，这将使被调函数的形参变量“指向”主调函数中，需要更改的那个变量；
//在被调函数中，通过 * （指向）运算，间接地修改主调函数相关变量的值。

//9.4 变量生命域与作用域
//9.4.1 全局变量与局部变量
//(1) 全局变量定义在 {} 之外；在{}之内定义的和形参变量都是局部变量；
//(2) 全局变量能被那些，其后定义的函数所引用；局部变量只能被定义它的函数所引用；
//(3) 全局变量的空间在主函数运行之前申请，在主函数结束后（即，整个程序完毕后）才释放空间；局部变量在定义它的函数被调用时才申请空间，函数结束而释放空间
//(4) 全局变量在定义后赋值前，其值由 C 语言强制赋值为 0；局部变量在定义后赋值前，其值为垃圾；
//9.4.2 变量存储类型
//自动存储类：auto （可缺省）int a; <= > auto signed int
//静态存储类：static
//寄存器存储类：register
//外部存储类：extern
//(1) 静态存储类变量是在主函数运行前申请空间，且在整个程序运行结束后释放
//(2) 静态存储类变量在定义后未赋值前，其值被 C 语言强行赋值为 0; 自动存储类变量在定义后未赋值前，其值为垃圾值；
//(3) 静态存储类变量，如果是局部变量，则只能被定义它的函数所引用；
//(4) 若某函数定义有静态变量；则，在该函数结束后，它所定义的自动变量被释放，静态变量不释放；下一次被调用时，静态变量在上一次，因此，静态变量具有“累加”效应。

//9.5 函数遗留问题

//10 结构体、共用体、动态存储分配、define、typedef
//10.1 结构体与共用体
//10.1.1 结构体
//结构体的定义仅是“设计、蓝图”，不占内存，实例化后，才真正占空间。
//10.1.2 共用体
//共用体的诸成员共同使用同一起始地址空间。
//共用体空间大小取决于，最大成员的长度。

//10.2 宏定义与用户自定义类型
//10.2.1 宏定义
//#define 标识符 被替换的信息
//提高程序,可维护性,可读性
//10.2.2 用户自定义类型
//typedef  已有类型  新类型;

//10.3 动态存储分配
//10.3.1 静态存储分配：以前所定义的变量，数组统统属于静态存储分配方式。
//10.3.2 动态存储分配
//malloc() 和 free()
//避免内存泄露


/*
int main() {
	//char *p = "I love you";
	//p = "Hello";
	//printf("p=%s\n", p);
	//printf("p[2]=%c\n",p[2]);
	//p[2] = 'm';  //错误，字符串常量是不能进行赋值操作的

	//char s[] = "china";
	//char* s2 = _strrev(s);
	//printf("s2=%s\n",s2);


	system("pause");
	return 0;
};
*/



//---------EDN电子技术设计  ---------
//1 C语言关键词volatile的用法
//(1) 在C / C++嵌入式代码中，你是否经历过下面的情况：
//(2) 代码执行正常C直到你打开了编译器优化
//(3) 代码执行正常C直到打开了中断
//(4) 古怪的硬件驱动
//(5) RTOS的任务独立运行正常C直到生成了其他任务

//volatile是用于声明变量时的使用限定符。
//它告诉编译器该变量值可能随时发生变化，且这种变化并不是代码引起的。
//给编译器这个暗示是很重要的。

//1.1 C语言关键字volatile语法
//(1) 声明一个变量为volatile
//volatile int foo;
//int volatile foo;

//(2) 声明一个指针为volatile --> 很常见，尤其是I/O寄存器的地址映射
//volatile uint8_t * pReg;
//uint8_t volatile * pReg;

//(3) 声明一个struct或者union为volatile
//在struct或union前使用volatile关键字，表明struct或union的所有内容都是volatile。
//如果这不是你的本意，可在struct或union成员上使用volatile关键字。

//1.2 正确使用C语言关键字volatile
//只要变量可能被意外修改，就需要把该变量声明为volatile。实际应用中，只有三种类型数据可能被修改。
//(1) 外设寄存器地址映射
//(2) 在中断服务程序中修改全局变量
//(3) 在多线程、多任务应用中，全局变量被多个任务读写

//1.3 外设寄存器
//嵌入式系统包含真正的硬件，通常会有复杂的外设。这些外设寄存器的值可能被异步的修改。
//为了告诉编译器真正意图，需要修改函数声明

//1.4 中断服务程序
//在中断服务程序中，经常会修改一些全局变量值，来作为主程序中的判断条件。
//解决方式: 全局变量etx_rcvd声明为volatile，所有问题(当然，也可能是部分)就消失了。

//1.5 多线程应用
//即使在程序中加入抢占式调度器，编译器依然不知道什么是，或何时发生上下文切换。
//从概念上讲，多任务与中断服务程序中,修改全局变量的做法是相同的。因此，所有这类全局变量都应该声明为volatile

//1.6 最后的思考































































































































































