

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
// #include <limits.h>


//03 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

//3.1 为什么需要复杂度分析？
//事后统计法: 把代码跑一遍，通过统计、监控，得到算法的执行时间和占用内存大小。
//局限性:
//(1)依赖测试环境
//(2)受数据规模的影响很大
//所以，需要一个不用具体的测试数据来测试，就可粗略地估计算法执行效率的方法。

//3.2 大 O 复杂度表示法
//T(n)=O(f(n)), 其中f(n): 每行代码执行的次数总和
//并不具体表示代码真正的执行时间，而是代码执行时间随数据规模增长的变化趋势  -->  渐进时间复杂度  -->  时间复杂度
//公式中低阶、常量、系数不左右增长趋势，可省略

//3.3 时间复杂度分析
//三个比较实用的方法:
//(1) 只关注循环执行次数最多的一段代码
//(2) 加法法则：总复杂度等于量级最大的那段代码的复杂度
//(3) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

//3.4 几种常见时间复杂度实例分析
//(1) O(1): 代码执行时间与n无关
//只要算法中不存在循环，递归语句，则时间复杂度为O(1)
//(2) O(logn), O(n*logn)
//O(n*logn)=n*logn --> 归并排序、快速排序
//(3) O(m+n), O(m*n)

//3.5 空间复杂度分析
//算法的存储空间随数据规模增长的变化趋势  -->  渐进空间复杂度

//3.6 内容小结
//复杂度低阶到高阶: O(1) < O(logn) < O(n) < O(n*logn) < O(n^2)
//复杂度分析不难，关键在于多练

//3.7 课后思考
//有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？
//而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？
//你怎么看待这个问题呢？



//04 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
//4.1 最好、最坏情况时间复杂度
//最好情况时间复杂度: 最理想情况下，代码的时间复杂度
//最坏情况时间复杂度: 最糟糕情况下，代码的时间复杂度

//4.2 平均情况时间复杂度
//加权平均/期望时间复杂度
//大多数情况下，不需要区分最好、最坏、平均时间复杂度
//只有同一块代码在不同的情况下，时间复杂度有量级的差距, 才会用这3种复杂度表示法来区分

//4.3 均摊时间复杂度  -->  特殊的平均时间复杂度
//应用的场景更加特殊/有限
//摊还分析法, 来分析均摊时间复杂度:
//(1)大部分情况下时间复杂度很低，个别情况较高，而且这些操作间存在前后连贯的时序关系
//(2)将这一组操作放在一块分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他较低的操作上。
//(3)能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度 == 最好时间复杂度

//4.4 内容小结
//同一代码，在不同输入的情况下，复杂度量级有可能不一样
//更全面地表示一段代码的执行效率

//4.5 课后思考



//05 数组：为什么很多编程语言中数组都从0开始编号？
//5.1 如何实现随机访问？
//定义: 一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
//(1) 线性表Linear List: 数组，链表、队列、栈
//数据排成线一样的结构。线性表上的各数据最多只有前后两个方向。
//非线性表: 二叉树、堆、图
//数据之间并不是简单的前后关系
//(2) 连续的内存空间和相同类型的数据  -->  随机访问
//删除、插入比较低效
//(3)寻址公式: a[i]_address = base_address + i * data_type_size
//(4)数组支持随机访问，时间复杂度为O(1)

//5.2 低效的“插入”和“删除”
//5.2.1 插入操作
//(1)数组元素有序: 搬移 k 之后的数据  -->  平均时间复杂度O(n)
//(2)无序: 将第k位的数据移到最后，把新元素放入第k个位置  -->  复杂度O(1)  --> 快排
//5.2.2 删除操作
//在某些特殊场景下，不一定非得追求数据的连续性: 将多次删除操作集中在一起, 提高删除的效率
//先记录已删除的数据。每次删除操作不是真正地搬移数据，只是记录数据已被删除。当数组没有更多空间存储数据时，才执行一次真正的删除操作

//5.3 警惕数组的访问越界问题
//访问数组的本质是访问一段连续内存，只要通过偏移计算到的内存地址可用，那么程序可能不报任何错误

//5.4 容器能否完全替代数组？
//数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。
//多维数组时，用数组会更直观
//(1) 业务开发，直接使用容器就足够
//(2) 非常底层的开发，比如开发网络框架，性能优化要做到极致，此时数组优于容器，成为首选。

//5.5 解答开篇
//从数组存储的内存模型来看，“下标”最确切的定义是“偏移（offset）”
//负数下标，比如 Python

//5.6 内容小结
//最基础、最简单的数据结构
//数组用一块连续内存空间，存储相同类型的一组数据，最大特点是支持随机访问, 插入、删除操作平均时间复杂度O(n)
//业务开发可直接使用编程语言提供的容器类，但特别底层的开发，数组可能更合适。

//5.7 课后思考
//前面讲到一维数组的内存寻址公式，思考，二维数组的内存寻址公式？
//address = base_address + ( i * n + j) * type_size



//06 链表（上）：如何实现LRU缓存淘汰算法?
//缓存: 一种提高数据读取性能的技术
//缓存淘汰策略: 当缓存用满时，哪些数据应该被清理/保留
//(1)先进先出策略 FIFO: First In First Out
//(2)最少使用策略 LFU: Least Frequently Used
//(3)最近最少使用策略 LRU: Least Recently Used

//6.1 五花八门的链表结构
//通过指针将一组零散的内存的内存块串联使用。
//6.1.1 单链表
//节点: 一个个零散的内存块
//插入和删除操作快速， 时间复杂度O(1)
//
//6.1.2 双向链表
//有后继指针和前驱指针: next和prev
//支持双向遍历
//某些情况下，插入，删除操作比单链表简单高效
//
//6.1.3 循环单链表  -->  尾节点指向头节点
//适合处理具有环形结构的数据
//6.1.4 删除操作
//(1)删除节点中，值等于某个给定值的节点
//必须从头节点开始，依次遍历对比，直到cur->val==key, 然后通过指针操作将其删除   -->  时间复杂度O(n)
//(2)删除给定指针指向的节点
//单链表: O(n)
//双链表: O(1)
//6.1.5 插入操作
//在某个指定节点前插入新节点
//单链表: O(n)
//双链表: O(1)
//6.1.6 查询
//双向链表效率更高，因为可以记录上次查找的位置，根据cur->val与key的关系，决定往前、往后
//6.1.7 交换
//(1)空间换时间
//(2)时间换空间
//6.1.8 双向循环链表

//6.2 链表 VS 数组性能大比拼
//(1)数组:大小固定，可借助CPU的缓存机制，预读数组中的数据，提高访问效率
//(2)链表:容易造成内存碎片，大小不限制，动态扩容，插入删除快速
//应该根据具体情况，权衡选择

//6.3 解答开篇
//维护一个有序单链表，越靠近尾部是越早前访问的
//当有一个新数据被访问时，从链表头开始顺序遍历
//6.3.1 此数据之前已被缓存在链表中，遍历得到此数据对应的结点，并将其从原位置删除，然后再插入到链表头部
//6.3.2 此数据没有在缓存链表中，又可以分为2种情况：
//(1) 缓存未满，将此结点直接插到链表头部；
//(2) 缓存已满，链表尾结点删除，将新数据结点插入链表头部
//6.3.3 缓存访问的时间复杂度为O(n)
//还可引入散列表(Hash Table)来记录各数据的位置，将缓存访问的时间复杂度降为O(1)
//6.3.4 也可用数组来实现

//6.4 内容小结
//更适合插入、删除操作频繁的场景，查询的时间复杂度较高。
//在具体开发中，要对数组和链表的各种性能进行对比，综合选择使用哪一个

//6.5 课后思考
//如果字符串用单链表存储，如何判断是一个回文串？你有什么解决思路？相应的时间空间复杂度？



//07 链表（下）：如何轻松写出正确的链表代码？
//成功的先决条件: 自己有决心并且付出精力
//技巧 + 主动和坚持

//7.1 技巧一：理解指针或引用的含义
//指针: 存储所指对象的内存地址

//7.2 技巧二：警惕指针丢失和内存泄漏
//7.2.1 插入节点时，要注意操作顺序
//在单链表的节点a,b之间插入新节点x (p指向a节点)
//x->next=p->next;
//p->next=x;
//7.2.2 删除节点
//记得手动释放内存空间

//7.3 技巧三：利用哨兵简化实现难度
//7.3.1 头结点的插入逻辑不一样
//if (head == NULL) head=new_node;
//7.3.2 节点删除
//尾节点: if (p->next == NULL) p=NULL;
//其他节点: p->next=p->next->next;
//7.3.3 哨兵: 解决边界问题，不直接参与业务逻辑
//哨兵节点一直存在，其不存数据， 上面的代码可以统一为相同的实现逻辑
//其他场景: 插入、归并排序，动态规划
//7.3.4 例子
//下面第二段代码，通过哨兵a[n-1]=key, 省了一个比较语句i<n, 当执行几十万次时，累计时间可观

// int findKey(int* a, int n, int key) {
//     if (a==NULL || n<=0) return -1;
//     int i=0;
//     while (i<n) {
//         if (a[i] == key) return i;
//         ++i;
//     }
//     return -1;
// }

// int findKey(int* a, int n, int key) {
//     if (a==NULL || n<=0) return -1;
//     if (a[n-1] == key) return n-1;
//
//     int tmp=a[n-1];
//     a[n-1]=key;
//     int i=0;
//     while (a[i] != key) ++i;
//     a[n-1]=tmp;
//
//     if (i == n-1) return -1;
//     else i;
// }

//7.4 技巧四：重点留意边界条件处理
//常见的边界条件:
//(1)链表为空
//(2)只有1个节点
//(3)只有2个节点
//(4)头尾节点
//(5)特定的边界条件

//7.5 技巧五：举例画图，辅助思考
//(1) 举一个具体例子,照着代码走一遍
//(2) 画图法

//7.6 技巧六：多写多练，没有捷径
//7.6.1 常见的操作:
//(1)单链表反转
//(2)链表中环的检测
//(3)两个有序链表的合并
//(4)删除链表中倒数第k个节点
//(5)求链表中间节点
//7.6.2 把常见的操作多谢几遍，出问题一点点调试，熟能生巧

//7.7 内容小结
//写链表代码最考验逻辑思维能力
//指针操作，边界处理

//7.8 课后思考
//哪些其他场景，可利用哨兵大大地简化编码难度？



//08 栈：如何实现浏览器的前进和后退功能？
//8.1 如何理解“栈”？
//是一种操作受限的线性表，只能在一端插入和删除数据。先进后出，后进先出。
//功能上: 数组或链表可以代替栈
//使用上: 数组或链表暴露太多接口，虽自由但不可控，容易出错。
//特定的数据结构是对特定场景的抽象

//8.2 如何实现一个“栈”？
//8.2.1 顺序栈: 数组
//8.2.2 链式栈: 链表
//8.2.3 复杂度分析
//入栈、出栈: 2种栈的时间/空间复杂度都是O(1)
//存储数据需要大小为n的数组

/*
typedef struct ArrayStack {
    int* arr;
    int top;
    int maxsz;
}AStk;

AStk* InitAStk(int maxsz) {
    AStk* p=(AStk*)malloc(sizeof(AStk));
    p->arr=(int*)malloc(sizeof(int) * maxsz);
    p->top=-1;
    p->maxsz=maxsz;
    return p;
}

bool pushKey(AStk* p, int key) {
    if (p->top == p->maxsz - 1) return false;
    p->arr[++p->top]=key;
    return true;
}

int popKey(AStk* p) {
    if (p->top == -1) return -1;
    return p->arr[p->top--];
}

void PrintAStk(AStk* p) {
    printf("ArraySatck = ");
    int n=p->top;
    for (int i=0; i<=n; ++i) {
        printf("%d ",p->arr[i]);
    }
    printf("\n");
}
*/

/*
typedef struct ListNode {
    int val;
    struct ListNode* next;
}LN;

typedef struct ListStack {
    LN* top;
    int size;
}LStk;

LN* createNode(int val) {
    LN* p=(LN*)malloc(sizeof(LN));
    p->val=val;
    p->next=NULL;
    return p;
}

LStk* InitLStk() {
    LStk* p = (LStk*)malloc(sizeof(LStk));
    p->top=NULL;
    p->size=0;
    return p;
}

void pushKey(LStk* p, int val) {
    LN* newNode=createNode(val);
    if (p->top != NULL) newNode->next=p->top;
    p->top=newNode;
    ++p->size;
}

int popKey(LStk* p) {
    if (p->top == NULL) return -1;
    int rt=p->top->val;
    p->top=p->top->next;
    --p->size;
    return rt;
}

void printLStk(LStk* p) {
    printf("ListStack = ");
    LN* cur=p->top;
    int n=p->size;
    for (int i=0;i<n;++i) {
        printf("%d ",cur->val);
        cur=cur->next;
    }
    printf("\n");
}
*/

//8.3 支持动态扩容的顺序栈
//8.3.1 用数组实现的顺序栈，大小固定。初始化时需指定栈大小，栈满时，无法往栈中添加数据。
//8.3.2 支持动态扩容: 底层依赖一个支持支持动态扩容的数组
//8.3.3 重点: 复杂度分析
//(1)出栈: 时间复杂度O(1)
//(2)入栈: 有无空闲空间，时间复杂度分别是O(1), O(n)
//均摊法分析平均时间复杂度O(1)

//8.4 栈在函数调用中的应用
// OS给各线程分配一块独立内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。
// 每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完，返回之后，将这个函数对应的栈帧出栈。

//8.5 栈在表达式求值中的应用
//通过两个栈来实现: 操作数栈，运算符栈。
//从左向右遍历表达式，遇到数字，直接压入操作数栈；遇到运算符，就与运算符栈的栈顶元素进行比较:
// 优先级 > 运算符栈顶元素，将当前运算符压入栈；
// 优先级 <= 运算符栈顶元素，从运算符栈中取栈顶，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算结果压入操作数栈，继续比较。

//8.6 栈在括号匹配中的应用
//检查表达式中的括号是否匹配
//用栈保存未匹配的左括号，从左到右依次扫描字符串。
//遇到左括号，压入栈; 遇到右括号，从栈顶取出一个左括号: 匹配则继续扫描。
//在扫描过程中若遇到不匹配的右括号，或栈为空了，则为非法格式
//扫描完成后，若栈为空，则合法；否则有未匹配的左括号，为非法格式。

//8.7 解答开篇

//8.8 内容小结
//栈的最大特点: 后进先出
//顺序、链式栈: 入栈、出栈时间复杂度都是O(1)

//8.9 课后思考
//什么函数调用要用“栈”保存临时变量呢？用其他数据结构不行吗？
//(1) 不一定非要用栈，只是如果这个函数调用符合后进先出的特性，用栈来实现，是最顺理成章的选择。
//(2) 从调用函数进入被调函数，对于数据来说，变化的是什么呢？是作用域。
//所以根本上，只要能保证每进入一个新函数，都是一个新作用域就可以。而要实现这个，用栈就非常方便。
//在进入被调函数时，分配一段栈空间给这个函数的变量，函数结束时，将栈顶复位，正好回到调用函数的作用域内。


/*
int main(void) {
    // AStk* pstk=InitAStk(16);
    // pushKey(pstk,1); pushKey(pstk,2); pushKey(pstk,3);
    // PrintAStk(pstk);//1 2 3
    // popKey(pstk);
    // PrintAStk(pstk);//1 2
    
    LStk* p=InitLStk();
    pushKey(p,1); pushKey(p,2); pushKey(p,3);
    printLStk(p);
    popKey(p);
    printLStk(p);
    
    return 0;
}
*/



//09 队列：队列在线程池等有限资源池中的应用
//过多的线程可能导致CPU频繁切换，使得处理性能下降。
//线程池的大小综合考虑处理任务的特点和硬件环境，事先设置。
//当相线程池中请求一个线程时，若无资源，则处理策略什么样？

//9.1 如何理解“队列”？
//操作受限的线性表，先进先出
//具有额外特性的队列: 循环、阻塞、并发队列  -->  偏底层系统、框架、中间件的开发中，起着关键性的作用

//9.2 顺序队列和链式队列
//9.2.1 数组
//(1)队头指针 head
//(2)队尾指针 tail
//(3)出队时不搬移数据，在入队是若无空闲空间，才触发一次数据搬移
//9.2.2 链表
//(1)队头指针 head
//(2)队尾指针 tail

/*
typedef struct ArrayQueue {
    int* arr;
    int n; //maxsize
    int size;//cursize
    int head;
    int tail;
}AQue;

AQue* InitAQue(int maxsz) {
    AQue* p=(AQue*)malloc(sizeof(AQue));
    p->arr=(int*)malloc(sizeof(int) * maxsz);
    p->n=maxsz;
    p->size = p->head = p->tail = 0;
}

bool enAQueue1(AQue* p, int val) {
    if (p->tail == p->n) return false;
    p->arr[p->tail++]=val;
    ++p->size;
    return true;
}

bool enAQueue2(AQue* p, int val) {
    if (p->tail == p->n) {
        if (p->head == 0) return false; //整个队列全满了
        for (int i=p->head; i<p->tail; ++i) {
            p->arr[i-p->head] = p->arr[i];
        }
        p->tail -= p->head;
        p->head=0;
    }
    p->arr[p->tail++]=val;
    ++p->size;
    return true;
}

int deAQueue(AQue* p) {
    if (p->head == p->tail) return -1;
    --p->size;
    return p->arr[p->head++];
}

void printAQue(AQue* p) {
    printf("ArrayQueue = ");
    int sz=p->size;
    int k=p->head;
    for (int i=0; i<sz; ++i) {
        printf("%d ",p->arr[i+k]);
    }
    printf("\n");
}
*/

/*
typedef struct ListNode {
    int val;
    struct ListNode* next;
}LN;

typedef struct ListQueue {
    LN* head;
    LN* tail;
    int size;
}LQue;

LN* createLN(int val) {
    LN* p=(LN*)malloc(sizeof(LN));
    p->val=val;
    p->next=NULL;
    return p;
}

LQue* InitLQue() {
    LQue* p=(LQue*)malloc(sizeof(LQue));
    p->head=p->tail=NULL;
    p->size=0;
    return p;
}

void enLQue(LQue* p, int val) {
    LN* newNode=createLN(val);
    if (p->size == 0)
        p->head=p->tail=newNode;
    else {
        p->tail->next = newNode;
        p->tail = p->tail->next;
    }
    ++p->size;
}

int deLQue(LQue* p) {
    if (p->size == 0) return -1;
    if (p->size == 1) p->tail=NULL;
    int rt=p->head->val;
    p->head=p->head->next;
    --p->size;
    return rt;
}

void printLQue(LQue* p) {
    printf("ListQueue = ");
    LN* cur=p->head;
    int sz=p->size;
    for (int i=0; i<sz; ++i) {
        printf("%d ", cur->val);
        cur=cur->next;
    }
    printf("\n");
}
*/

//9.3 循环队列  -->  避免数据搬移
//最关键: 确定好队空和队满的判断条件:
//(1)队空: head == tail
//(2)队满: (tail+1)%n == head
//tail指向的位置不存数据，会浪费一个数组元素的空间

/*
typedef struct CircularQueue {
    int* arr;
    int n;//maxsize
    int size;//cursize
    int head;
    int tail;
}CQue;

CQue* InitCQue(int maxsz) {
    CQue* p=(CQue*)malloc(sizeof(CQue));
    p->arr=(int*)malloc(sizeof(int) * maxsz);
    p->n=maxsz;
    p->size = p->head = p->tail = 0;
}

bool enCQue(CQue* p, int val) {
    if ((p->tail+1) % p->n == p->head) return false;
    p->arr[p->tail]=val;
    p->tail = (p->tail+1) % p->n;
    ++p->size;
    return true;
}

int deCQue(CQue* p) {
    if (p->size == 0) return -1;
    int rt=p->arr[p->head];
    p->head = (p->head+1) % p->n;
    --p->size;
    return rt;
}

void printCQue(CQue* p) {
    printf("CircularQueue = ");
    int k=p->head;
    int sz=p->size;
    for (int i=0; i<sz; ++i) {
        printf("%d ", p->arr[i+k]);
    }
    printf("\n");
}
*/


//9.4 阻塞队列和并发队列
//9.4.1 阻塞队列
//队列为空时，从队头取数据会被阻塞，直到队列中有数据才能返回
//队列满时，插入操作被阻塞，直到队列有空闲位置才插入数据，再返回。
//这个定义: 生产者-消费者模型
//还可通过协调“生产者”和“消费者”的个数，提高数据的处理效率
//9.4.2 并发队列
//在多线程情况下，会有多个线程同时操作队列，此时会存在线程安全问题
//最简单直接的实现方式: 在 enqueue()、dequeue() 上加锁，但锁粒度大并发度会比较低，同一时刻仅允许一个存/取操作
//基于数组的循环队列，利用 CAS 原子操作，可实现非常高效的并发队列  -->  循环队列比链式队列应用更广泛的原因

//9.5 解答开篇
//9.5.1 非阻塞的处理方式，直接拒绝任务请求；
//9.5.2 阻塞的处理方式，将请求排队，等有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？
//公平地处理每个排队的请求，先进者先服务, 队列
//(1)链式队列: 
//支持无限排队的无界队列（unbounded queue） -->  响应时间过长
//(2)顺序队列:
//基于数组实现的有界队列（bounded queue），队列的大小有限
//请求超过队列大小时，接下来的请求就会被拒绝， -->  设置一个合理的队列大小，也是非常有讲究的
//9.5.3 
//对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

//9.6 内容小结
//循环队列是我们这节的重点。
//阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。课后思考

//9.7 课后思考
// 除了线程池这种池结构会用到队列排队请求，有哪些类似的池结构或场景中会用到队列的排队请求呢？
// 关于如何实现无锁并发队列，有非常多的讨论。对这个问题，你怎么看呢？
// 可以使用 cas + 数组的方式, 实现无锁并发队列。
// 分布式消息队列，如 kafka 也是一种队列。

/*
int main(void) {
    // AQue* p=InitAQue(16);
    // enAQueue2(p,1); enAQueue2(p,2); enAQueue2(p,3);
    // printAQue(p);
    // deAQueue(p);
    // printAQue(p);
    
    // LQue* p=InitLQue();
    // enLQue(p,1); enLQue(p,2); enLQue(p,3);
    // printLQue(p);//1 2 3
    // deLQue(p);
    // printLQue(p);//2 3
    
    CQue* p=InitCQue(16);
    enCQue(p,1); enCQue(p,2); enCQue(p,3);
    printCQue(p);//1 2 3
    deCQue(p);
    printCQue(p);//2 3
    
    return 0;
}
*/



//10 递归：如何用三行代码找到“最终推荐人”？
//10.1 如何理解“递归”？
//应用: DFS深度优先搜索、前中后序二叉树遍历
//去的过程叫“递”，回来的过程叫“归”。

//10.2 递归需要同时满足的3个条件
//(1) 原问题的解可分解为几个子问题的解
//(2) 原问题与子问题，除数据规模不同，求解思路完全一样
//(3) 存在递归终止条件

//10.3 如何编写递归代码？
//最关键: 写出递推公式，找到终止条件
//编写递归代码的关键: 把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

//10.4 递归代码要警惕堆栈溢出
//避免堆栈溢出: 限制递归调用的最大深度, 当超过最大深度时，直接返回报错
//不能完全解决问题，因为最大允许递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。

//10.5 递归代码要警惕重复计算
//通过一个数据结构（比如散列表）来保存已求解过的 f(k)
//当调用到f(k) 时，先看是否已求解过。如果是，则直接从散列表中取值返回
//递归的其他问题:
//(1)函数调用的数量较大时, 时间成本较大
//(2)空间复杂度较高， 递归调用一次就会在内存栈中保存一次现场数据，

//10.6 怎么将递归代码改写为非递归代码？
//利: 递归代码的表达力很强，写起来非常简洁；
//弊: 空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题
//10.6.1 所有递归代码都可改为迭代循环的非递归
//因为递归本身是借助栈来实现，只不过用的栈是系统或虚拟机提供的

//10.7 解答开篇
//10.8 内容小结
//(1)递归是一种高效、简洁的编码技巧。只要满足“3个条件”的问题就可通过递归代码来解决
//(2)写递归代码的关键: 不要绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。
//(3)弊端: 堆栈溢出、重复计算、函数调用耗时多、空间复杂度高

//10.9 课后思考
//对于递归代码，你有什么好的调试方法呢？
// 调试递归:
// 1.打印日志发现，递归值。
// 2.结合条件断点进行调试。



//11 排序（上）：为什么插入排序比冒泡排序更受欢迎？

// void mswap(int* a, int i, int j) {
//     if (a[i] != a[j]) {
//         a[i] ^= a[j]; 
//         a[j] ^= a[i];
//         a[i] ^= a[j];
//     }
//     // int tmp=a[i];
//     // a[i]=a[j];
//     // a[j]=tmp;
// }

void printArr(int* a, int n) {
    printf("arr = ");
    for (int i=0; i<n; ++i) {
        printf("%d ",a[i]);
    }
    printf("\n");
}

//11.1 如何分析一个“排序算法”？
//11.1.1 排序算法的执行效率
//(1)最好情况、最坏情况、平均情况时间复杂度
//有序度不同,排序算法的性能表现不同
//
//(2)时间复杂度的系数、常数 、低阶
//时间复杂度同阶时，需要考虑系数、常数、低阶
//
//(3)比较次数和交换/移动次数
//基于比较的排序算法，执行过程涉及2种操作:
//1) 元素比较大小
//2) 元素交换/移动
//
//11.1.2 排序算法的内存消耗  -->  空间复杂度
//原地排序Sorted in place: 特指空间复杂度O(1)的排序算法
//这小节都是原地算法

//11.1.3 排序算法的稳定性
//稳定性: 排序后，相等元素间原有的先后顺序不变
//稳定排序算法可保持金额相同的两个对象，在排序后的前后顺序不变。

//11.2 冒泡排序Bubble Sort
//只会操作相邻数据。每次冒泡都是比较相邻元素
//一次冒泡至少一个元素移动到它应该的位置，重复n次，就完成n个数据的排序

//(1) 原地排序？
//只需常量级的临时空间，空间复杂度O(1), 是的。
//
//(2) 稳定排序？
//相邻元素大小相等时不交换，是稳定的。
//
//(3) 时间复杂度？
//(3.1) 最好: 只需1次冒泡O(n)
//(3.2) 最坏: n次冒泡O(n^2)
//有序度: 数组中具有有序关系的元素对的个数
//满有序度: 完全有序的数组的有序度n*(n-1)/2
//逆序度 = 满有序度 - 有序度
//排序过程: 增加有序度，减少逆序度，最后达到满有序度
//交换次数总是确定的，即为逆序度
//(3.3) 平均交换次数
//(0 + n*(n-1)/2)/2 = n*(n-1)/4

// void BubbleSort(int* a, int n) {
//     if (n<=1) return;
//     bool flag=true;
//     for (int i=0; i<n; ++i) {
//         flag=true;//提前退出冒泡循环的标志位
//         for (int j=0; j<n-i-1; ++j) {
//             if (a[j] > a[j+1]) {
//                 a[j]   ^= a[j+1];
//                 a[j+1] ^= a[j];
//                 a[j]   ^= a[j+1];
//                 flag=false;//表示有数据交换 
//             }
//         }
//         if (flag) break;//没有数据交换，提前退出
//     }
// }

//11.3 插入排序Insertion Sort
//数据分为: 已排序/未排序区间。
//11.3.1 核心思想: 取未排序区间中的元素，在已排序区间中找合适位置插入，并保证已排序区间数据一直有序。
//重复这个过程，直到未排序区间为空，算法结束。
//11.3.2 涉及2种操作:
//(1)元素比较: a插到已排序区间时，要拿a与已排序区间元素依次比较，找到合适的插入位置
//不同的查找插入点方法（从头到尾、从尾到头），比较次数有区别
//(2)元素移动: 还需将插入点后的元素顺序往后移动一位，腾出位置给元素a插入
//给定初始序列，移动次数总是固定，等于逆序度
//
//11.3.3
//(1) 原地排序？
//只需1个int的额外存储空间，是的。
//(2) 稳定排序？
//值相同的元素，可选择将后面的元素，插到前面元素的后面，前后顺序不变.是的。
//(3) 时间复杂度？
//最好: 从尾到头遍历已有序的数据O(n)
//最坏: 数组倒序, 每次都是在第一个位置插入新数据O(n^2)
//平均: 在数组中插入一个数据的平均时间复杂度O(n)
//每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，平均时间复杂度O(n^2)

// void InsertSort(int* a, int n) {
//     if (n<=1) return;
//     for (int i=1; i<n; ++i) {
//         int val=a[i];
//         int j=i-1;
//         while (j >= 0 && a[j] > val) {
//             a[j+1]=a[j];
//             --j;
//         }
//         a[j+1]=val;
//     }
// }

//11.4 选择排序（Selection Sort）
//实现思路有点类似插入排序，也分已排序/未排序区间
//核心思想: 每次从未排序区间中找最小元素，放到已排序区间末尾

//(1) 原地排序？
//只需1个int的额外存储空间，是的。
//(2) 稳定排序？
//每次都找未排序元素中的最小值，并和前面元素交换位置，破坏了稳定性
//(3) 时间复杂度？
//最好，最坏，平均都是O(n^2)

// void SelectSort(int* a, int n) {
//     if (n<=1) return;
//     int minIdx;
//     for (int i=0; i<n-1; ++i) {
//         minIdx=i;
//         for (int j=i+1; j<n; ++j) {
//             if (a[j] < a[minIdx]) minIdx=j;
//         }
//         if (minIdx != i) mswap(a,minIdx,i);
//     }
// }

//11.5 解答开篇
//冒泡排序，元素交换次数固定，是原始数据的逆序度。
//插入排序，元素移动次数固定, 是原始数据的逆序度。
//冒泡排序的数据交换比插入排序的数据移动要复杂，冒泡排序需3个赋值操作，而插入排序只需1个
//插入排序的优化  -->  希尔排序

//11.6 内容小结
//11.6.1 对比:
//          原地    稳定    最好、最坏、平均
//冒泡      Y       Y       O(n) O(n^2) O(n^2)
//插入      Y       Y       O(n) O(n^2) O(n^2)
//选择      Y       N       O(n^2) O(n^2) O(n^2)
//有些编程语言中的排序函数的实现原理, 会用到插入排序算法
//这节的算法: 大规模数据，时间复杂度稍微有点高

//11.7 课后思考
//特定算法是依赖特定的数据结构
//如果数据在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？
//
//应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，
//冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；
//插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入；
//选择排序比较次数一致，交换操作同样比较麻烦。
//综上，时间/空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。

/*
int main(void) {
    int arr[6]={3,5,6,1,3,2};
    //BubbleSort(arr,6);
    InsertSort(arr,6);
    //SelectSort(arr,6);
    printArr(arr,6);
    return 0;
}
*/



//12 排序（下）：如何用快排思想在O(n)内查找第K大元素？
//本节适合大规模的数据排序，用到分治思想

//12.1 归并排序的原理 Merge Sort
//12.1.1 核心思想: 先把数组从中间分成前后两部分，对前后分别排序，再将排好序的两部分合并，这样整个数组就都有序了
//12.1.2 分治算法一般用递归实现: 分治是一种解决问题的处理思想，递归是一种编程技巧
//递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
//终止条件：p >= r 不用再继续分解

//12.2 归并排序的性能分析
//12.2.1 稳定
//12.2.2 如何分析递归代码的时间复杂度?
//T(a) = T(b) + T(c) + K  -->  T(n) = 2*T(n/2) + n； n>1;  T(1)=C
//T(n)=2^k * T(n/(2^k)) + kn  --> T(n)=C*n + n*logn  --> O(n*logn)
//执行效率与有序度无关，时间复杂度稳定，都是O(n*logn)
//12.2.3 不是原地
//合并两个有序数组为一个时，需借助额外存储空间 --> 临时内存空间最大 <= n
//空间复杂度O(n)

/*
void merge1(int* a, int l, int q, int r) {
    int i=l,j=q+1,k=0;
    int* rt=(int*)malloc(sizeof(int)*(r-l+1));
    while (i<=q && j<=r) {
        if (a[i] <= a[j]) rt[k++]=a[i++];
        else rt[k++]=a[j++];
    }
    int beg=i,end=q;
    if (j <= r) {
        beg=j;
        end=r;
    }
    while (beg<=end) rt[k++]=a[beg++];
    for (int n=0; n<=r-l; ++n)
        a[n+l]=rt[n];
}

void merge2(int* a, int l, int q, int r) {
    int* la=(int*)malloc(sizeof(int)*(q-l+2));
    int* ra=(int*)malloc(sizeof(int)*(r-q+1));
    for (int i=0; i<=q-l; ++i)
        la[i]=a[l+i];
    la[q-l+1]= INT_MAX;
    for (int i=0; i<r-q; ++i)
        ra[i]=a[q+1+i];
    ra[r-q]=INT_MAX;

    int i=0,j=0,k=l;
    while (k <= r) {
        if (la[i] <= ra[j]) a[k++]=la[i++];
        else a[k++]=ra[j++];
    }
    free(la);
    free(ra);
}

void MergeSort(int* a, int l, int r) {
    if (l>=r) return;
    int q=(l+r)/2;
    MergeSort(a,l,q);
    MergeSort(a,q+1,r);
    //merge2(a,l,q,r);
    merge1(a,l,q,r);
}
*/

//12.3 快速排序的原理 Quicksort
//用到分治思想，但和归并排序思路不一样
//核心思想: 
//(1) 如果要排序下标p到r的一组数据，选择p到r之间任意一个数据作为pivot（分区点）。
//(2) 遍历p到r之间的数据，小于pivot到左边，大于pivot到右边，pivot到中间
//(3) 根据分治、递归的处理思想: 可用递归排序 下标从p到q-1之间的数据 和 下标从q+1到r之间的数据，直到区间缩小为1，说明所有数据都有序
//递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)
//终止条件：p >= r
//12.3.2 原地分区函数partion
//通过游标i把A[p…r-1]分成两部分: A[p…i-1]的元素小于pivot，“已处理区间”，A[i…r-1]是“未处理区间”
//每次从未处理区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加到已处理区间的尾部，也就是 A[i]的位置
//12.3.3 数组某个位置插入元素
//只需将 A[i]与 A[j]交换，就可在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。
//12.3.4 区别
//(1) 归并排序: 处理过程由下到上的，先处理子问题，然后再合并。
//非原地, 合并函数无法在原地执行
//(2) 快排: 处理过程由上到下的，先分区，然后再处理子问题。
//原地分区函数，可以实现原地排序

//12.4 快速排序的性能分析
//12.4.1 不稳定: 因为分区过程涉及交换操作
//12.4.2 时间复杂度
//最好: 分区极其均衡O(n*logn)
//最坏: 分区极其不均衡O(n^2)
//平均: O(n*logn)

// int partion(int* a, int l, int r) {
//     int pivot=a[r];
//     int i=l;
//     for (int j=l; j<r; ++j) {
//         if (a[j] < pivot) {
//             if (i != j) mswap(a,i,j);
//             ++i;
//         }
//     }
//     mswap(a,i,r);
//     return i;
// }
// void QuickSort(int* a, int l, int r) {
//     if (l>=r) return;
//     int q=partion(a,l,r);
//     QuickSort(a,l,q-1);
//     QuickSort(a,q+1,r);
// }

//12.5 解答开篇
//快排核心思想就是分治和分区
//选择区间A[0…n-1]的最后元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成3部分，A[0…p-1]、A[p]、A[p+1…n-1]
//(1) 如果 p+1=K，A[p]就是要求解的元素；
//(2) 如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，再按上面思路递归地在 A[p+1…n-1]区间内查找
//(3) 同理，如果 K<p+1，在A[0…p-1]区间查找

// int partion(int* a, int p, int r) {
//     int pivot=a[r];
//     int i=p;
//     for (int j=p; j<r; ++j) {
//         if (a[j] <= pivot) {
//             mswap(a,i,j);
//             ++i;
//         }
//     }
//     mswap(a,i,r);
//     return i;
// }
// int SmallestK(int* a, int n, int k) {
//     if (a==NULL || n<k) return -1;
//     int p=partion(a,0,n-1);
//     while (p+1 != k) {
//         if (p+1<k) p=partion(a,p+1,n-1);
//         else p=partion(a,0,p-1);
//     }
//     return a[p];
// }

//12.6 内容小结
//都是分治的思想，代码都通过递归来实现，过程非常相似
//归并排序的重点: 理解递推公式和 merge() 合并函数。快排的重点: 理解递推公式，partition() 分区函数
//归并排序: 时间复杂度都比较稳定, 不是原地排序算法，空间复杂度比较高，是 O(n)
//快速排序: 平均时间复杂度O(n*logn), 合理地选择 pivot 来避免退化到O(n^2)

//12.7 课后思考
//有 10 个接口访问日志文件，各日志文件大小300MB，各文件里的日志都按照时间从小到大排序。希望将 10个较小的日志文件，合并为1个日志文件，合并后的日志仍按时间从小到大排列。
//如果机器内存只有1GB，有什么好的解决思路，能“快速”地将这 10 个日志文件合并？


// int main(void) {
//     int arr[8]={11,8,3,9,7,1,2,11};
//     //MergeSort(arr,0,8-1);
//     //QuickSort(arr,0,8-1);
//     int t=SmallestK(arr,8,3);
//     printf("t=%d\n",t);
//     printArr(arr,8);
//     return 0;
// }



//13 线性排序：如何根据年龄给100万用户数据排序？
//本节算法的时间复杂度O(n), 但对数据要求很苛刻

//13.1 桶排序 Bucket sort
//13.1.1 核心思想: 将数据分到几个有序的桶里，各桶的数据再单独排序。桶内排序后，再把各桶里的数据按照顺序依次取出，组成有序
//13.1.2 对数据的要求:
//(1)很容易划分成m个桶, 桶之间有天然的大小顺序
//(2)各桶间的分布比较均匀
//13.1.3 适合外部排序
//外部排序: 数据存在外部磁盘中，量大，内存有限，无法将数据全部加载到内存中。
//若某些桶的数据较多，可继续划分。
//13.1.4 时间复杂度
//数据量n,m个桶，各桶数据量k=n/m
//O(m*k*logk)=O(n*log(n/m))  -->  若m接近n,则 O(n)

/*
typedef struct Barrel {
    int* val;
    int blen;
}Bar;
void BucketSort(int* a, int n, int bsz) {
    if (n<2) return;
    int minval=a[0], maxval=a[0];
    for (int i=1; i<n; ++i) {
        if (a[i] < minval) minval=a[i];
        else if (a[i] > maxval) maxval=a[i];
    }

    int bcnt=(maxval-minval+1)/bsz + 1;
    Bar* pB=(Bar*)malloc(sizeof(Bar) * bcnt);
    memset(pB,0,sizeof(Bar) * bcnt);
    for (int i=0; i<bcnt; ++i) {
        pB[i].val=(int*)malloc(sizeof(int) * bsz);
        memset(pB[i].val,0,sizeof(int) * bsz);
    }

    int k;
    for (int i=0; i<n; ++i) {
        k=(a[i]-minval+1)/bsz;
        pB[k].val[pB[k].blen]=a[i];
        ++pB[k].blen;
    }

    int idx=0;
    for (int i=0; i<bcnt; ++i) {
        if (pB[i].blen != 0) {
            QuickSort(pB[i].val, 0, pB[i].blen-1);
            for (int j=0; j<pB[j].blen; ++j)
                a[idx++]=pB[i].val[j];
        }
    }

    for (int i=0; i<bcnt; ++i)
        free(pB[i].val);
    free(pB);

}
*/

//13.2 计数排序 Counting sort
//(1) 桶排序的一种特殊情况:
//要排序的n个数据范围不大，比如最大值k，就可把数据分成k个桶。各桶内的数据值都相同，省掉桶内排序的时间
//(2) 计数”的含义来自哪里呢？
//用另一个数组来计数
//(3) 只能给非负整数排序，如果数据是其他类型，在不改变相对大小情况下，转化为非负整数

/*
void CountSort(int* a, int n) {
    if (n <= 1) return;
    int maxv=a[0];
    for (int i=1; i<n; ++i) {
        if (a[i] > maxv) maxv=a[i];
    }

    int* CA=(int*)malloc(sizeof(int) * (maxv+1)); //计数数组，下标大小[0,maxv]
    memset(CA,0,sizeof(int) * (maxv+1)); //必须初始化为0
    for(int i=0; i<n; ++i)
        ++CA[a[i]];//各元素的个数
    for (int i=1;i<maxv+1;++i)
        CA[i] += CA[i-1];//依次累加

    int* r=(int*)malloc(sizeof(int)*n); //临时数组r，存储排序结果
    memset(r,0,sizeof(int)*n); //必须初始化为0
    for (int i=n-1; i>=0; --i) {
        int idx=CA[a[i]]-1;
        r[idx]=a[i];
        --CA[a[i]];
    }

    for (int i=0; i<n; ++i)
        a[i]=r[i];
}
*/

//13.3 基数排序 Radix sort
//用稳定排序算法，从后往前按每位来排序
//13.3.1 对数据的要求:
//(1)数据数据可划分成高低位，位之间有递进关系
//如果a数据的高位 比 b数据大，那剩下的低位不用比较
//(2)每一位的数据范围不能太大，要可以用线性排序算法。否则，线性排序算法的时间复杂度做不到O(n)
//13.3.2 时间复杂度
//O(k*n): 数据有k位，数据量有n个

/*
void CntSort(int* a, int n, int exp) {
    if (n <= 1) return;
    int CA[10]={0};
    for(int i=0; i<n; ++i)
        ++CA[(a[i] / exp) % 10];//各元素的个数
    for (int i=1; i<10; ++i)
        CA[i] += CA[i-1];//依次累加

    int r[10];
    for (int i=n-1; i>=0; --i) {
        r[CA[(a[i] / exp) % 10] - 1]=a[i];
        --CA[(a[i] / exp) % 10];
    }
    for (int i=0; i<n; ++i)
        a[i]=r[i];
}
void RadixSort(int* a, int n) {
    if (n <= 1) return;
    int maxv=a[0];
    for (int i=1; i<n; ++i) {
        if (a[i] > maxv) maxv=a[i];
    }
    for (int i=1; maxv/i>0; i *= 10)
        CntSort(a,n,i);
}
*/

//13.4 解答开篇
//Bucket sort
//根据年龄将其划分到120 个桶里

//13.5 内容小结
//桶/计数: 排序思想非常相似，都是针对范围不大的数据，将数据分成不同的桶
//基数排序: 要求数据可分成高低位，位之间有递进关系

//13.6 课后思考
//对 D，a，F，B，c，A，z 字符串排序，要求将其中所有小写字母都排在大写字母前面，但小写/大写字母内部不要求有序
//还有数字。要将小写字母到前面，大写字母在最后，数字在中间，不用排序算法，又该怎么解决呢？

// int main(void) {
//     int arr[10]={78, 17, 39, 26, 72, 94, 21, 12, 23, 91};
//     //BucketSort(arr,10,4);
//     //CountSort(arr,10);
//     RadixSort(arr,10);
//     printArr(arr,10);
//     return 0;
// }



//14 排序优化：如何实现一个通用的、高性能的排序函数？
//14.1 如何选择合适的排序算法？
//为兼顾任意规模数据, 首选时间复杂度为O(n*logn)的算法: 归并，快排，堆排序
//归并的空间复杂度O(n),不常用

//14.2 如何优化快速排序？
//14.2.1 复杂度恶化: 
//数据接近有序，每次分区点都选择最后一个，则时间复杂度退化到O(n^2)  -->  分区点选得不合理
//14.2.2 分区点选择方法:
//最理想分区点：被分区点分开的两个分区中，数据量差不多
//(1)三数取中法: pivot = middle(a[l], a[mid], a[r])  -->  若要排序的数组较大，则可能5数、10数取中
//(2)随机法: 每次从要排序的区间中，随机选择一个元素作为pivot

//14.3 举例分析排序函数
//Glibc中的qsort()函数，不仅仅用了快排1种算法
//(1)归并: 数据量较小
//(2)快排: 数据量较大  -->  实现一个堆上的栈，手动模拟递归来解决堆栈溢出
//若待排序区间元素个数<4, 使用插入排序O(n^2)
//哨兵来简化代码，提高执行效率

//14.4 内容小结
//大部分排序函数都用 O(nlogn) 算法实现，但为了尽可能地提高性能，会做很多优化。

//14.5 课后思考
//分析熟悉语言中的排序函数, 用什么排序算法实现的？都有哪些优化技巧？


//15 二分查找（上）：如何用最省内存的方式实现快速查找功能？
//针对有序数据集合的查找算法
//15.1 无处不在的二分思想
//查找思想有点类似分治, 每次都跟区间中间元素对比，将待查找区间缩小为之前的一半，直到找到要查找的元素，或区间被缩小为0

//15.2 O(logn) 惊人的查找速度
//堆、二叉树的操作等，时间复杂度是O(logn)
//有时其执行效率高于O(1)， 因为时间复杂度会省略常数、系数和低阶

//15.3 二分查找的递归与非递归实现
//15.3.1 最简单情况: 有序数组中不存在重复元素
//15.3.2 易出错的3个地方:
//(1)循环退出条件: low<=high
//(2)mid 的取值: mid=low+(hign+low)/2
//(3)low 和 high 的更新: low=mid+1, high=mid-1

// int bSearch1(int* a, int n, int key) {
//     int low=0,high=n-1;
//     while (low <= high) {
//         int mid=low+(low+high)/2;
//         if (a[mid] == key) return mid;
//         else if (a[mid] < key) low=mid+1;
//         else high=mid-1;
//     }
//     return -1;
// }
// int bSearch2(int* a, int low, int high, int key) {
//     if (low>high) return -1;
//     int mid =  low + ((high - low) >> 1);
//     if (a[mid] == key) return mid;
//     else if (a[mid] < key) return bSearch2(a,mid+1,high,key);
//     else return bSearch2(a,low,mid-1,key);
// }

//15.4 二分查找应用场景的局限性
//15.4.1 依赖的是顺序表结构，数组
//不能依赖于链表，因为二分查找需要按下标随机访问元素
//只能用在数据是通过, 顺序表来存储的数据结构上

//15.4.2 针对有序数据
//(1)一组静态数据，没有频繁插入/删除，可进行一次排序，多次二分查找
//(2)数据集合有频繁的插入和删除, 每次插入、删除操作后保证数据仍有序, 每次二分查找前都先排序
//只能用在插入、删除操作不频繁，一次排序多次查找
//动态数据集合 --> 二叉树

//15.4.3 数据量太小不适合
//数据量太小，顺序遍历足够。数据量比较大，才能体现二分查找的优势。
//若数据比较操作耗时，则无论数据量大小，都推荐二分查找。

//15.4.4 数据量太大也不适合
//数组要求内存空间连续，对内存要求严格。

//15.5 解答开篇
//(1) 存在数组中需要80MB < 100MB, 先排序再用二分查找
//(2) 散列表、二叉树这些支持快速查找的动态数据结构, 不可以。
//虽然大部分情况下，用二分查找可解决的问题，用散列表、二叉树都可以
//但后两者需要较多的额外内存空间

//15.6 内容小结
//二分查找核心思想: 每次跟区间中间元素对比，将待查找区间缩小为一半，直到找到key元素，或区间被缩小为0
//3个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。
//应用场景有限。底层必须依赖数组，数据必须有序

//15.7 课后思考
//(1) 编程实现“求一个数的平方根”？要求精确到小数点后6位
//(2) 如果数据用链表存储，二分查找的时间复杂是多少呢
//T(n)=n/2 + n/4 + ......+1=n-1  --> O(n)

/*
double SQRT(double x) {
    double low=0.0,mid;
    double high= x>=1 ? x : 1.0/x;
    while (low < high && fabs(mid*mid - x) > 1e-6) {
        mid=(low+high)/2;
        if (mid*mid <= x) low=mid;
        else high=mid;
    }
    return mid;
}

int main(void) {
    int arr[9]={1,3,5,7,9,8,6,4,2};
    //int rt=bSearch1(arr,9,3);
    // int rt=bSearch2(arr,0,9-1,3);
    // printf("rt=%d\n", rt);//1
    double srt=SQRT(0.8);//1.8
    printf("rt=%f\n", srt);//0.894427, 1.341641
    return 0;
}
*/



//16 二分查找（下）：如何快速定位IP对应的省份地址？
//一个说法：“十个二分九个错”  -->  要写出没有 Bug 的二分查找并不容易
//前提: 数据从小到大

//16.1 变体1：查找第一个值等于给定值的元素 (数据存在重复元素)

// int bsearch12(int* a, int n, int key) {
//     int low=0,high=n-1;
//     while (low <= high) {
//         int mid=low + ((high - low) >> 1);
//         if (a[mid] > key) high=mid-1;
//         else if (a[mid] < key) low=mid+1;
//         else {
//             if (mid==0 || a[mid-1] != key) return mid;
//             else high=mid-1;
//         }
//     }
//     return -1;
// }

//16.2 变体2：查找最后一个值等于给定值的元素

// int bsearch21(int* a, int n, int key) {
//     int low=0,high=n-1;
//     while (low <= high) {
//         int mid=low + ((high - low) >> 1);
//         if (a[mid] > key) high=mid-1;
//         else if (a[mid] < key) low=mid+1;
//         else {
//             if (mid==n-1 || a[mid+1] != key) return mid;
//             else low=mid+1;
//         }
//     }
//     return -1;
// }

//16.3 变体3：查找第一个大于等于给定值的元素

// int bsearch31(int* a, int n, int key) {
//     int low=0,high=n-1;
//     while (low <= high) {
//         int mid=low + ((high - low) >> 1);
//         if (a[mid] >= key) {
//             if (mid==0 || a[mid-1] < key) return mid;
//             else high=mid-1;
//         }
//         else low=mid+1;
//     }
//     return -1;
// }

//16.4 变体4：查找最后一个小于等于给定值的元素

// int bsearch41(int* a, int n, int key) {
//     int low=0,high=n-1;
//     while (low <= high) {
//         int mid=low + ((high - low) >> 1);
//         if (a[mid] > key) high=mid-1;
//         else {
//             if (mid==n-1 || a[mid+1] > key) return mid;
//             low=mid+1;
//         }
//     }
//     return -1;
// }

//16.5 解答开篇
//P 地址可转化为32位的整型数, 从小到大排序. 问题就可以转化为我刚讲的第四种变形问题
//找到最后一个起始IP <= 这个IP的IP区间

//16.6 内容小结
//(1)凡是用二分查找能解决的，绝大部更倾向用散列表或二叉查找树
//(2)二分查找更适合用在“近似”查找，这类问题上，二分查找优势更明显
//(3)易错的细节: 终止条件、区间上下界更新方法、返回值选择。

//16.7 课后思考
//有序数组是一个循环有序数组，比如 4，5，6，1，2，3。如何实现一个求“值等于给定值”的二分查找算法
//假设数组中不存在重复的元素. 返回它的索引，否则返回 -1

/*
int searchKey(int* a, int n, int key) {
    if (a==NULL || n==0) return -1;
    int l=0,r=n-1;
    int m;
    while (l <= r) {
        m=l + ((r - l) >> 1);
        if (a[m] == key) return m;
        if (a[l] <= a[m]) { //旋转后变为 4, 5, 6, 7, 0, 1, 2
            if (a[l] <= key && key < a[m]) r=m-1;
            else l=m+1;
        }
        else {  //旋转后变为 5, 6, 7, 0, 1, 2, 4
            if (key > a[m] && key <= a[r]) l=m+1;
            else r=m-1;
        }
    }
    return -1;
}

int main(void) {
    // int arr[10]={1,3,4,5,6,8,8,8,11,18};
    // int r1=bsearch12(arr,10,8);
    // int r2=bsearch21(arr,10,8);
    // int r3=bsearch31(arr,10,8);
    // int r4=bsearch41(arr,10,8);
    // printf("r1=%d\n",r1);//5
    // printf("r2=%d\n",r2);//7
    // printf("r3=%d\n",r3);//5
    // printf("r4=%d\n",r4);//7
    
    int arr[9]={4,5,6,7,8,9,1,2,3};
    int idx=searchKey(arr,9,2);
    printf("idx=%d\n", idx);//7
    return 0;
}
*/



//17 跳表：为什么Redis一定要用跳表来实现有序集合？



//18 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？




//19 散列表（中）：如何打造一个工业级水平的散列表？



//20 散列表（下）：为什么散列表和链表经常会一起使用？


//21 哈希算法（上）：如何防止数据库中的用户信息被脱库？


//22 哈希算法（下）：哈希算法在分布式系统中有哪些应用？

